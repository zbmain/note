- **均值滤波**：利用滤波器（核结构、卷积核，filter，kernel），大小一般是奇数。
  - anchor：核结构的中心点，锚点
- **高斯滤波**：
  - 1、生成符合二维高斯分布的滤波器的权重
  - 2、对权重进行归一化
  - 3、使用归一化后的滤波器对原图像进行高斯滤波
  - 应用场景：原图像中包含的噪声都是高斯噪声
- **中值滤波**：
  - 使用像素点周围邻域的灰度值的中值作为这个像素点滤波操作之后的结果
  - 应用场景：原图像中包含噪声是椒盐噪声
- **灰度直方图**：
  - 作用：观察图像中像素强弱分布状况
  - 掩膜（mask、蒙版）：
    - 提取感兴趣的区域
    - 屏蔽
    - 结构特征提取
  - **直方图均衡化**
    - 提高原始图像的对比度
    - 全局的操作
  - **自适应均衡化**：
    - 1、将整幅图像进行分块，8*8这样的数目的块
    - 2、分别对每一个小块做直方图均衡化
    - 3、对块的边界区域进行插值并进行块的拼接
    - 实现：
      - API：实例化自适应均衡化的对象：clahe = cv.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
      - 在原图像上进行应用：cl1 = clahe.apply(img)
- **边缘检测**：
  - 1、基于搜索，通过寻找图像的一阶导数中的最大值，sobel、Scharr
  - 2、基于零穿越，通过寻找图像的二阶导数中为零的点，Laplacian
  - **Sobel算子**：
    - 1、根据得到的卷积核去分别计算出X方向和Y方向的梯度
    - 2、然后对这两个方向的梯度进行合并
    - 3、对合并后的结果图进行展示
    - 注意：当我们指定ksize=-1时，此时的Sobel算子是Scharr算子
    - **API中的Ddepth参数指的是存储每个像素所用的位数，一般为了防止计算出来的梯度被截断，损失部分信息，都会采用较大的位数存储，例如 CV_16S，CV_64F。**
  - Laplacian算子：
    - 1、基于零穿越，即像素的二阶导去寻找一阶导数的极大值
  - **Canny算子**：
    - 迄今为止，效果最好的边缘检测方法
    - 1、取出噪声，因为边缘检测这样的操作对噪声敏感
    - 2、求取X方向和Y方向的梯度以及梯度的方向
    - 3、非极大抑制
    - 4、设置滞后阈值，通过设置minVal和maxVal判断该点像素是否为边界点，大于maxVal的被认为是真正的边界点，小于minVal的点被舍弃掉，介于这两个阈值之间的点，判断是否和真正的边界点相连，如果是，则被判断成边界点，反之，不是。
- **模板匹配**：
  - 1、先要有这样的一个模板图片
  - 2、根据模板图片形成的滑动窗口去原图片中寻找相似度最大的匹配位置
  - 3、根据得到的最大值对应的左上角像素的坐标以及模板的宽和高绘制匹配出来的矩形区域
  - 对原图像的尺度敏感
- 霍夫变换：
  - 1、构建累加器，对于每一个直线上的点（x, y）分别用于统计不同 $$\theta$$ 角度计算下的 $$\rho$$ 值，存入累加器，如果这个数值在上述累加器中存在相应的位置，则在该位置上加1，对于不同的点，每次更新累加器中的值
  - 2、搜索累加器中的最大值所对应的（$$\rho$$, $$\theta$$），用于表示图像中的直线。