


<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-5.2.3">
    
    
      
        <title>RCNN系列网络 - 深度学习与CV</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.6e35a1a6.min.css">
      
      
    
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    <body dir="ltr">
  
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#42-r-cnn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="深度学习与CV" class="md-header-nav__button md-logo" aria-label="深度学习与CV">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      
        <div class="md-header-nav__ellipsis">
          <span class="md-header-nav__topic md-ellipsis">
            深度学习与CV
          </span>
          <span class="md-header-nav__topic md-ellipsis">
            
              RCNN系列网络
            
          </span>
        </div>
      
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active">
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
        
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="深度学习与CV" class="md-nav__button md-logo" aria-label="深度学习与CV">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    深度学习与CV
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-1" type="checkbox" id="nav-1">
    
    <label class="md-nav__link" for="nav-1">
      课程介绍
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="课程介绍" data-md-level="1">
      <label class="md-nav__title" for="nav-1">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        课程介绍
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/section1/" title="深度学习" class="md-nav__link">
      深度学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../introduction/section2/" title="计算机视觉（CV）" class="md-nav__link">
      计算机视觉（CV）
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      tensorflow入门
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="tensorflow入门" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        tensorflow入门
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tensorFlow/section1/" title="tensorflow和keras简介" class="md-nav__link">
      tensorflow和keras简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tensorFlow/section2/" title="快速入门模型" class="md-nav__link">
      快速入门模型
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      深度神经网络
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="深度神经网络" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        深度神经网络
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../deeplearning/section1/" title="神经网络简介" class="md-nav__link">
      神经网络简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../deeplearning/section2/" title="常见的损失函数" class="md-nav__link">
      常见的损失函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../deeplearning/section3/" title="深度学习的优化方法" class="md-nav__link">
      深度学习的优化方法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../deeplearning/section4/" title="深度学习的正则化" class="md-nav__link">
      深度学习的正则化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../deeplearning/section5/" title="神经网络案例" class="md-nav__link">
      神经网络案例
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../deeplearning/section6/" title="卷积神经网络CNN" class="md-nav__link">
      卷积神经网络CNN
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      图像分类
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="图像分类" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        图像分类
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section1/" title="图像分类简介" class="md-nav__link">
      图像分类简介
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section2/" title="AlexNet" class="md-nav__link">
      AlexNet
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section3/" title="VGG" class="md-nav__link">
      VGG
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section4/" title="GoogLeNet" class="md-nav__link">
      GoogLeNet
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section5/" title="ResNet" class="md-nav__link">
      ResNet
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section6/" title="图像增强方法" class="md-nav__link">
      图像增强方法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageClassification/section7/" title="模型微调" class="md-nav__link">
      模型微调
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" checked>
    
    <label class="md-nav__link" for="nav-5">
      目标检测
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="目标检测" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        目标检测
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../01.overview/" title="目标检测概述" class="md-nav__link">
      目标检测概述
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        RCNN系列网络
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 9h14V7H3v2m0 4h14v-2H3v2m0 4h14v-2H3v2m16 0h2v-2h-2v2m0-10v2h2V7h-2m0 6h2v-2h-2v2z"/></svg>
        </span>
      </label>
    
    <a href="./" title="RCNN系列网络" class="md-nav__link md-nav__link--active">
      RCNN系列网络
    </a>
    
      
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1overfeat" class="md-nav__link">
    1.Overfeat模型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2rcnn" class="md-nav__link">
    2.RCNN模型
  </a>
  
    <nav class="md-nav" aria-label="2.RCNN模型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 算法流程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 算法总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-fast-rcnn" class="md-nav__link">
    3. Fast RCNN模型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4fasterrcnn" class="md-nav__link">
    4.FasterRCNN模型
  </a>
  
    <nav class="md-nav" aria-label="4.FasterRCNN模型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41backbone" class="md-nav__link">
    4.1backbone
  </a>
  
    <nav class="md-nav" aria-label="4.1backbone">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#411-resnet" class="md-nav__link">
    4.1.1 ResNet
  </a>
  
    <nav class="md-nav" aria-label="4.1.1 ResNet">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1.瓶颈模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-resnet" class="md-nav__link">
    2. resnet
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#412-fpn" class="md-nav__link">
    4.1.2 fpn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-rpn" class="md-nav__link">
    4.2 RPN网络
  </a>
  
    <nav class="md-nav" aria-label="4.2 RPN网络">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421-anchors" class="md-nav__link">
    4.2.1 anchors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#422-rpn" class="md-nav__link">
    4.2.2 RPN分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#423-rpn" class="md-nav__link">
    4.2.3 RPN回归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#424-proposal-layer" class="md-nav__link">
    4.2.4 Proposal Layer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-roipooling" class="md-nav__link">
    4.3 ROIPooling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-classifierregression" class="md-nav__link">
    4.4 Classifier+Regression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-fasterrcnn" class="md-nav__link">
    4.5 FasterRCNN的训练
  </a>
  
    <nav class="md-nav" aria-label="4.5 FasterRCNN的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#451-rpn" class="md-nav__link">
    4.5.1 RPN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="4.5.1 RPN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1、正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2rpn" class="md-nav__link">
    2、RPN网络的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3、训练过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#452-fastrcnn" class="md-nav__link">
    4.5.2 FastRCNN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="4.5.2 FastRCNN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1.正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2fastrcnn" class="md-nav__link">
    2.FastRCNN的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    3.训练过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#453" class="md-nav__link">
    4.5.3 共享卷积训练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../03.RCNN-demo/" title="Faster RCNN案例" class="md-nav__link">
      Faster RCNN案例
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../04.yolo/" title="YOLO系列算法" class="md-nav__link">
      YOLO系列算法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../05.yolo-demo/" title="YOLOV3案例" class="md-nav__link">
      YOLOV3案例
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../06.ssd/" title="SSD算法" class="md-nav__link">
      SSD算法
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-nav__toggle md-toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      目标分割
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8.59 16.58L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.42z"/></svg>
      </span>
    </label>
    <nav class="md-nav" aria-label="目标分割" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        <span class="md-nav__icon md-icon">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
        </span>
        目标分割
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageSegmentation/section1/" title="目标分割介绍" class="md-nav__link">
      目标分割介绍
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageSegmentation/section2/" title="语义分割：FCN和UNet" class="md-nav__link">
      语义分割：FCN和UNet
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageSegmentation/section3/" title="UNet案例" class="md-nav__link">
      UNet案例
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../imageSegmentation/section4/" title="实例分割：Mask RCNN" class="md-nav__link">
      实例分割：Mask RCNN
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1overfeat" class="md-nav__link">
    1.Overfeat模型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#2rcnn" class="md-nav__link">
    2.RCNN模型
  </a>
  
    <nav class="md-nav" aria-label="2.RCNN模型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21" class="md-nav__link">
    2.1 算法流程
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22" class="md-nav__link">
    2.2 算法总结
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#3-fast-rcnn" class="md-nav__link">
    3. Fast RCNN模型
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#4fasterrcnn" class="md-nav__link">
    4.FasterRCNN模型
  </a>
  
    <nav class="md-nav" aria-label="4.FasterRCNN模型">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#41backbone" class="md-nav__link">
    4.1backbone
  </a>
  
    <nav class="md-nav" aria-label="4.1backbone">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#411-resnet" class="md-nav__link">
    4.1.1 ResNet
  </a>
  
    <nav class="md-nav" aria-label="4.1.1 ResNet">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1.瓶颈模块
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-resnet" class="md-nav__link">
    2. resnet
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#412-fpn" class="md-nav__link">
    4.1.2 fpn
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-rpn" class="md-nav__link">
    4.2 RPN网络
  </a>
  
    <nav class="md-nav" aria-label="4.2 RPN网络">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#421-anchors" class="md-nav__link">
    4.2.1 anchors
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#422-rpn" class="md-nav__link">
    4.2.2 RPN分类
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#423-rpn" class="md-nav__link">
    4.2.3 RPN回归
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#424-proposal-layer" class="md-nav__link">
    4.2.4 Proposal Layer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-roipooling" class="md-nav__link">
    4.3 ROIPooling
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-classifierregression" class="md-nav__link">
    4.4 Classifier+Regression
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-fasterrcnn" class="md-nav__link">
    4.5 FasterRCNN的训练
  </a>
  
    <nav class="md-nav" aria-label="4.5 FasterRCNN的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#451-rpn" class="md-nav__link">
    4.5.1 RPN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="4.5.1 RPN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_1" class="md-nav__link">
    1、正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2rpn" class="md-nav__link">
    2、RPN网络的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3" class="md-nav__link">
    3、训练过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#452-fastrcnn" class="md-nav__link">
    4.5.2 FastRCNN网络的训练
  </a>
  
    <nav class="md-nav" aria-label="4.5.2 FastRCNN网络的训练">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1_2" class="md-nav__link">
    1.正负样本标记
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2fastrcnn" class="md-nav__link">
    2.FastRCNN的损失函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3_1" class="md-nav__link">
    3.训练过程
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#453" class="md-nav__link">
    4.5.3 共享卷积训练
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                  
                
                
                <h1 id="42-r-cnn">4.2 R-CNN系列网络<a class="headerlink" href="#42-r-cnn" title="Permanent link">&para;</a></h1>
<p><strong>学习目标</strong></p>
<ul>
<li>了解Overfeat模型的移动窗口方法</li>
<li>了解RCNN目标检测的思想</li>
<li>了解fastRCNN目标检测的思想</li>
<li>熟悉FasterRCNN目标检测的思想</li>
<li>知道anchor的思想</li>
<li>掌握RPN网络是如何进行候选区域的生成的</li>
<li>掌握ROIPooling的使用方法</li>
<li>知道fasterRCNN的训练方法</li>
</ul>
<hr />
<p><img alt="image-20200914143645050" src="../assets/image-20200914143645050.png" /></p>
<h2 id="1overfeat">1.Overfeat模型<a class="headerlink" href="#1overfeat" title="Permanent link">&para;</a></h2>
<p>Overfeat方法使用滑动窗口进行目标检测，也就是使用滑动窗口和神经网络来检测目标。滑动窗口使用固定宽度和高度的矩形区域，在图像上“滑动”，并将扫描结果送入到神经网络中进行分类和回归。</p>
<p><img alt="image-20200914151603803" src="../assets/image-20200914151603803.png" /></p>
<p>例如要检测汽车，就使用下图中红色滑动窗口进行扫描，将所有的扫描结果送入网络中进行分类和回归，得到最终的汽车的检测结果。</p>
<p><img alt="image-20200914151303053" src="../assets/image-20200914151303053.png" /></p>
<p>这种方法类似一种暴力穷举的方式，会消耗大量的计算力，并且由于窗口大小问题可能会造成效果不准确。</p>
<h2 id="2rcnn">2.RCNN模型<a class="headerlink" href="#2rcnn" title="Permanent link">&para;</a></h2>
<p>在CVPR 2014年中Ross Girshick提出R-CNN网络，该网络不在使用暴力穷举的方法，而是使用候选区域方法（region proposal method），创建目标检测的区域来完成目标检测的任务，R-CNN是以深度神经网络为基础的目标检测的模型 ，以R-CNN为基点，后续的Fast R-CNN、Faster R-CNN模型都延续了这种目标检测思路。</p>
<h3 id="21">2.1 算法流程<a class="headerlink" href="#21" title="Permanent link">&para;</a></h3>
<p>RCNN的检测流程如下图所示：</p>
<p><img alt="image-20200914152426730" src="../assets/image-20200914152426730.png" /></p>
<p>步骤是：</p>
<ol>
<li><strong>候选区域</strong>：使用选择性搜索的方法找出图片中可能存在目标的侯选区域region proposal</li>
<li><strong>网络选择</strong>：选取预训练卷积神经网网络（AlexNet）用于进行特征提取。</li>
<li><strong>目标分类</strong>：训练支持向量机（SVM）来辨别目标物体和背景。对每个类别，都要训练一个二元SVM。</li>
<li><strong>目标定位</strong>：训练一个线性回归模型，为每个辨识到的物体生成更精确的边界框</li>
</ol>
<p>我们通过一个具体的例子来展示这个流程：</p>
<ul>
<li>选择一个图片进行目标检测：</li>
</ul>
<p><img alt="image-20200914153559343" src="../assets/image-20200914153559343.png" /></p>
<ul>
<li>利用选择性搜索获取候选区域</li>
</ul>
<p><img alt="image-20200914153640330" src="../assets/image-20200914153640330.png" /></p>
<ul>
<li>将这些候选区域进行变形，若是AlexNet将图片resize成227*227后送入到CNN网络中进行特征提取。</li>
</ul>
<p><img alt="image-20200914153828765" src="../assets/image-20200914153828765.png" /></p>
<ul>
<li>将CNN网络提取的特征结果送入到SVM中进行分类：</li>
</ul>
<p><img alt="image-20200914153914829" src="../assets/image-20200914153914829.png" /></p>
<ul>
<li>用线性回归的方法预测每个目标的边界框位置</li>
</ul>
<p><img alt="image-20200914154022046" src="../assets/image-20200914154022046.png" /></p>
<p>这就是整个RCNN算法的流程。</p>
<p><strong>【了解】选择性搜索（SelectiveSearch，SS）中</strong>，使用语义分割的方法，它通过在像素级的标注，把颜色、边界、纹理等信息作为合并条件，多尺度的综合采样方法，划分出一系列的区域，这些区域要远远少于传统的滑动窗口的穷举法产生的候选区域。</p>
<p><img src="../images/SS方法.png" style="zoom:50%;" /></p>
<p>SelectiveSearch在一张图片上提取出来约2000个侯选区域，<strong>需要注意的是这些候选区域的长宽不固定</strong>。 而使用CNN提取候选区域的特征向量，需要接受固定长度的输入，所以需要对候选区域做一些尺寸上的修改。</p>
<h3 id="22">2.2 算法总结<a class="headerlink" href="#22" title="Permanent link">&para;</a></h3>
<p>1、训练阶段多：步骤繁琐: 微调网络+训练SVM+训练边框回归器。</p>
<p>2、训练耗时：占用磁盘空间大：5000张图像产生几百G的特征文件。</p>
<p>3、处理速度慢: 使用GPU, <strong>VGG16模型处理一张图像需要47s</strong>。</p>
<p>4、图片形状变化：候选区域要经过crop/warp进行固定大小，无法保证图片不变形</p>
<h2 id="3-fast-rcnn">3. Fast RCNN模型<a class="headerlink" href="#3-fast-rcnn" title="Permanent link">&para;</a></h2>
<p>考虑到R-CNN速度很慢, 提出了一个改善模型:Fast R-CNN。 相比R-CNN, Fast R-CNN的优点在于加快了selective search的步骤和同时训练分类和回归过程, 从整体上加快了速度。</p>
<p>Fast R-CNN对R-CNN的改进部分:</p>
<ul>
<li>
<p>将R-CNN中三个模块(CNN, SVM, Regression)整合, 极大了减少了计算量和加快了速度</p>
</li>
<li>
<p>不对原始图像进行selective search提取, 而是先经过一次CNN, 在feature map上使用selective search生成候选区域进行映射, 并进行分类回归</p>
</li>
<li>
<p>为了兼容不同图片尺度, 使用了ROI Pooling 算法, 将特征图池化到固定维度的特征向量。</p>
</li>
</ul>
<p><img alt="image-20200914160228432" src="../assets/image-20200914160228432.png" /></p>
<p>fastRCNN的工作流程描述如下：</p>
<ul>
<li>输入图像：</li>
</ul>
<p><img alt="image-20200914160446836" src="../assets/image-20200914160446836.png" /></p>
<ul>
<li>图像被送入到卷积网络进行特征提取，将通过选择性搜索获取的候选区域映射到特征图中：</li>
</ul>
<p><img alt="image-20200914160610599" src="../assets/image-20200914160610599.png" /></p>
<ul>
<li>在特征图上Rol中应用RoIPooling，获取尺寸相同的特征向量</li>
</ul>
<p><img alt="image-20200914160737415" src="../assets/image-20200914160737415.png" /></p>
<ul>
<li>将这些区域传递到全连接的网络中进行分类和回归，得到目标检测的结果。</li>
</ul>
<p><img alt="image-20200914160830206" src="../assets/image-20200914160830206.png" /></p>
<h2 id="4fasterrcnn">4.FasterRCNN模型<a class="headerlink" href="#4fasterrcnn" title="Permanent link">&para;</a></h2>
<p>在R-CNN和Fast RCNN的基础上，Ross B. Girshick在2016年提出了Faster RCNN，在结构上，Faster RCNN已经将特征抽取(feature extraction)，proposal提取，bounding box regression(rect refine)，classification都整合在了一个网络中，使得综合性能有较大提高，在检测速度方面尤为明显。接下来我们给大家详细介绍fasterRCNN网络模型。网络基本结构如下图所示：</p>
<p><img alt="image-20200914161108604" src="../assets/image-20200914161108604.png" /></p>
<p>该网络主要可分为四部分：</p>
<ul>
<li><strong>Backbone</strong>：backbone由一组卷积神经网络构成，Faster RCNN首先使用一组基础的conv+relu+pooling层提取图像中的特征，获取图像的特征图featuremaps。该feature maps被共享用于后续RPN层和全连接层。</li>
<li><strong>RPN网络</strong>：RPN网络用于生成候选区域region proposals。该部分通过softmax判断anchors属于positive或者negative，即是否包含目标，再利用bounding box regression修正anchors获得精确的proposals。</li>
<li><strong>Roi Pooling</strong>: 该部分收集输入图像的feature maps和proposals，综合信息后提取proposal的特征向量，送入后续全连接层判定目标类别和确定目标位置。</li>
<li><strong>Classifier</strong>: 该部分利用特征向量计算proposal的类别，并通过bounding box regression获得检测框最终的精确位置</li>
</ul>
<p>将上述结构展开后如下所示，下图中特征提取网络是VGG16：</p>
<p><img alt="image-20200914162144207" src="../assets/image-20200914162144207.png" /></p>
<p>从上图中可以看出，对于一副任意大小PxQ的图像：</p>
<ul>
<li>
<p>首先将图像缩放至固定大小MxN，然后将MxN图像送入网络；</p>
</li>
<li>
<p>而Conv layers中包含了13个conv层+13个relu层+4个pooling层，在这里使用VGG16网络进行特征提取，将最后的全连接层舍弃。在整个Conv layers中，conv和relu层不改变输入输出大小，只有pooling层使输出长宽都变为输入的&frac12;，一共有4个池化层，所以：</p>
</li>
</ul>
<p>一个MxN大小的矩阵经过Conv layers固定变为(M/16)x(N/16）；</p>
<ul>
<li>
<p>RPN网络首先经过3x3卷积，再分别生成positive anchors和对应bounding box regression偏移量，然后计算出proposals；</p>
</li>
<li>
<p>而Roi Pooling层则利用proposals从feature maps中提取proposal feature送入后续全连接网络中进行分类和回归。</p>
</li>
</ul>
<p>接下来我们就从这四个方面来详细fasterRCNN网络并结合源码分析其实现过程。</p>
<h3 id="41backbone">4.1backbone<a class="headerlink" href="#41backbone" title="Permanent link">&para;</a></h3>
<p>backbone一般为VGG，ResNet等网络构成，主要进行特征提取，将最后的全连接层舍弃，得到特征图进行后续处理。</p>
<p>在源码中我们使用ResNet + FPN 结构，来提取特征。普通的 FasterRCNN 只需要将 feature_map 输入到 rpn 网络生成 proposals 即可。但是由于加入 FPN，需要将多个 feature_map 逐个输入到 rpn 网络和检测网络中：</p>
<p><img alt="image-20200917162104834" src="../assets/image-20200917162104834.png" /></p>
<p>在这里ResNet和FPN的完整结构如下图所示，RPN输入的feature map是[p2,p3,p4,p5,p6] ，而作为后续目标检测网络FastRCNN的输入则是 [p2,p3,p4,p5] 。</p>
<p><img alt="image-20201020141907780" src="../assets/image-20201020141907780.png" /></p>
<p>那网络的整体架构表示成：</p>
<p><img alt="image-20201020144728158" src="../assets/image-20201020144728158.png" /></p>
<p>接下来我们分析下相关内容及源码：</p>
<h4 id="411-resnet">4.1.1 ResNet<a class="headerlink" href="#411-resnet" title="Permanent link">&para;</a></h4>
<p>源码位置：fasterRCNN/detection/models/backbones/reset.py</p>
<h5 id="1">1.瓶颈模块<a class="headerlink" href="#1" title="Permanent link">&para;</a></h5>
<p>要构建resnet网络首先构建瓶颈模块如下所示：</p>
<p><img alt="image-20200917161037737" src="../assets/image-20200917161037737.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">_Bottleneck</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    瓶颈模块的实现</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filters</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> 
                 <span class="n">downsampling</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_Bottleneck</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># 获取三个卷积的卷积核数量</span>
        <span class="n">filters1</span><span class="p">,</span> <span class="n">filters2</span><span class="p">,</span> <span class="n">filters3</span> <span class="o">=</span> <span class="n">filters</span>
        <span class="c1"># 卷积层命名方式</span>
        <span class="n">conv_name_base</span> <span class="o">=</span> <span class="s1">&#39;res&#39;</span> <span class="o">+</span> <span class="n">block</span> <span class="o">+</span> <span class="s1">&#39;_branch&#39;</span>
        <span class="c1"># BN层命名方式</span>
        <span class="n">bn_name_base</span>   <span class="o">=</span> <span class="s1">&#39;bn&#39;</span>  <span class="o">+</span> <span class="n">block</span> <span class="o">+</span> <span class="s1">&#39;_branch&#39;</span>
        <span class="c1"># 是否进行下采样</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsampling</span> <span class="o">=</span> <span class="n">downsampling</span>
        <span class="c1"># 卷积步长</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>
        <span class="c1"># 瓶颈模块输出的通道数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_channel</span> <span class="o">=</span> <span class="n">filters3</span>
        <span class="c1"># 1*1 卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2a</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters1</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span>
                                    <span class="n">name</span><span class="o">=</span><span class="n">conv_name_base</span> <span class="o">+</span> <span class="s1">&#39;2a&#39;</span><span class="p">)</span>
        <span class="c1"># BN层</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn2a</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bn_name_base</span> <span class="o">+</span> <span class="s1">&#39;2a&#39;</span><span class="p">)</span>
        <span class="c1"># 3*3 卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2b</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters2</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span>
                                    <span class="n">name</span><span class="o">=</span><span class="n">conv_name_base</span> <span class="o">+</span> <span class="s1">&#39;2b&#39;</span><span class="p">)</span>
        <span class="c1"># BN层</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn2b</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bn_name_base</span> <span class="o">+</span> <span class="s1">&#39;2b&#39;</span><span class="p">)</span>
        <span class="c1"># 1*1卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2c</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span>
                                    <span class="n">name</span><span class="o">=</span><span class="n">conv_name_base</span> <span class="o">+</span> <span class="s1">&#39;2c&#39;</span><span class="p">)</span>
        <span class="c1"># BN层</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn2c</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bn_name_base</span> <span class="o">+</span> <span class="s1">&#39;2c&#39;</span><span class="p">)</span>
        <span class="c1"># 下采样</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsampling</span><span class="p">:</span>
            <span class="c1"># 在短连接处进行下采样</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">conv_shortcut</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">filters3</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="n">stride</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                                               <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span>
                                               <span class="n">name</span><span class="o">=</span><span class="n">conv_name_base</span> <span class="o">+</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>
            <span class="c1"># BN层</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bn_shortcut</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">bn_name_base</span> <span class="o">+</span> <span class="s1">&#39;1&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        定义前向传播过程</span>
<span class="sd">        :param inputs:</span>
<span class="sd">        :param training:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># 第一组卷积+BN+Relu</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2a</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn2a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 第二组卷积+BN+Relu</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2b</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn2b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 第三组卷积+BN</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2c</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn2c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="c1"># 短连接</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsampling</span><span class="p">:</span>
            <span class="n">shortcut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_shortcut</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
            <span class="n">shortcut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn_shortcut</span><span class="p">(</span><span class="n">shortcut</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shortcut</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="c1"># 相加求和</span>
        <span class="n">x</span> <span class="o">+=</span> <span class="n">shortcut</span>
        <span class="c1"># 激活</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 最终输出</span>
        <span class="k">return</span> <span class="n">x</span>
</code></pre></div>

<h5 id="2-resnet">2. resnet<a class="headerlink" href="#2-resnet" title="Permanent link">&para;</a></h5>
<p>利用瓶颈模块构建backbone中的resNet.</p>
<p><img alt="image-20200917164937649" src="../assets/image-20200917164937649.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">ResNet</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="s2">&quot;构建50或101层的resnet网络&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># 若深度不是50或101报错</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">101</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;depth must be 50 or 101.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>
        <span class="c1"># padding </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">padding</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">ZeroPadding2D</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="c1"># 输入的卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
                                   <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                                   <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span>
                                   <span class="n">name</span><span class="o">=</span><span class="s1">&#39;conv1&#39;</span><span class="p">)</span>
        <span class="c1"># BN层</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn_conv1</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;bn_conv1&#39;</span><span class="p">)</span>
        <span class="c1"># maxpooling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_pool</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">MaxPooling2D</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
        <span class="c1"># 第一组瓶颈模块</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res2a</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;2a&#39;</span><span class="p">,</span>
                                 <span class="n">downsampling</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res2b</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;2b&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res2c</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">256</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;2c&#39;</span><span class="p">)</span>
        <span class="c1"># 第二组瓶颈模块：首个进行下采样</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res3a</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;3a&#39;</span><span class="p">,</span> 
                                 <span class="n">downsampling</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res3b</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;3b&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res3c</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;3c&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res3d</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">512</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="c1"># 第三组瓶颈模块：首个进行下采样</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res4a</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4a&#39;</span><span class="p">,</span> 
                                 <span class="n">downsampling</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res4b</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4b&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res4c</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4c&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res4d</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4d&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res4e</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4e&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res4f</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4f&#39;</span><span class="p">)</span>
        <span class="c1"># 若深度为101还需进行瓶颈模块的串联</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">101</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4g</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4g&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4h</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4h&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4i</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4i&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4j</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4j&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4k</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4k&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4l</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4l&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4m</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4m&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4n</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4n&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4o</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4o&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4p</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4p&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4q</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4q&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4r</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4r&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4s</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4s&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4t</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4t&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4u</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4u&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4v</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4v&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">res4w</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">1024</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;4w&#39;</span><span class="p">)</span> 
        <span class="c1"># 第四组瓶颈模块：首个进行下采样</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res5a</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">2048</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;5a&#39;</span><span class="p">,</span> 
                                 <span class="n">downsampling</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res5b</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">2048</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;5b&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">res5c</span> <span class="o">=</span> <span class="n">_Bottleneck</span><span class="p">([</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">2048</span><span class="p">],</span> <span class="n">block</span><span class="o">=</span><span class="s1">&#39;5c&#39;</span><span class="p">)</span>
        <span class="c1"># 输出通道数：C2,C3,C4,C5的输出通道数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_channel</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">2048</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="s2">&quot;定义前向传播过程，每组瓶颈模块均输出结果&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">padding</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn_conv1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 第1组瓶颈模块：输出c2</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res2a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res2b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">C2</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res2c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="c1"># 第2组瓶颈模块:输出c3</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res3a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res3b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res3c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">C3</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res3d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="c1"># 第3组瓶颈模块:输出c4</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4e</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">==</span> <span class="mi">101</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4h</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4i</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4j</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4k</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4l</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4n</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4o</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4p</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4q</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4r</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4s</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4t</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4u</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4v</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res4w</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span> 
        <span class="n">C4</span> <span class="o">=</span> <span class="n">x</span>
        <span class="c1"># 第4组瓶颈模块:输出c5</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res5a</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res5b</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">C5</span> <span class="o">=</span> <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">res5c</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="c1"># 返回所有的输出送入到fpn中</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="p">,</span> <span class="n">C5</span><span class="p">)</span>
</code></pre></div>

<h4 id="412-fpn">4.1.2 fpn<a class="headerlink" href="#412-fpn" title="Permanent link">&para;</a></h4>
<p>FPN的作用是当前层的feature map会对未来层的feature map进行上采样，并加以利用。因为有了这样一个结构，当前的feature map就可以获得“未来”层的信息，这样的话低阶特征与高阶特征就有机融合起来了，提升检测精度。如下图所示：</p>
<p><img alt="image-20200917160440015" src="../assets/image-20200917160440015.png" /></p>
<p>整个架构中的结构如下图所示：</p>
<p><img alt="image-20201020151310473" src="../assets/image-20201020151310473.png" /></p>
<p>源码位置：fasterRCNN/detection/models/necks/fpn.py</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">FPN</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out_channels</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        构建FPN模块：</span>
<span class="sd">        out_channels:是输出特征图的通道数</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FPN</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># 输出通道数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_channels</span> <span class="o">=</span> <span class="n">out_channels</span>
        <span class="c1"># 使用1*1卷积对每个输入的特征图进行通道数调整</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c2p2</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_c2p2&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c3p3</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_c3p3&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c4p4</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_c4p4&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c5p5</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                      <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_c5p5&#39;</span><span class="p">)</span>
        <span class="c1"># 对深层的特征图进行上采样，使其与前一层的大小相同</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p3upsampled</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">UpSampling2D</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p3upsampled&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p4upsampled</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">UpSampling2D</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p4upsampled&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p5upsampled</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">UpSampling2D</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p5upsampled&#39;</span><span class="p">)</span>
        <span class="c1"># 3*3卷积，作用于融合后的特征图中得到最终的结果</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p2</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">,</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p2&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p3</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">,</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p3&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p4</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">,</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p4&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p5</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">out_channels</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;SAME&#39;</span><span class="p">,</span>
                                    <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p5&#39;</span><span class="p">)</span>
        <span class="c1"># 对上一层的特征图进行下采样得到结果</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p6</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">MaxPooling2D</span><span class="p">(</span><span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;fpn_p6&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c1"># 定义前向传播过程</span>
        <span class="c1"># 获取从resnet中得到的4个特征图</span>
        <span class="n">C2</span><span class="p">,</span> <span class="n">C3</span><span class="p">,</span> <span class="n">C4</span><span class="p">,</span> <span class="n">C5</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="c1"># 对这些特征图进行1*1卷积和上采样后进行融合</span>
        <span class="n">P5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c5p5</span><span class="p">(</span><span class="n">C5</span><span class="p">)</span>
        <span class="n">P4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c4p4</span><span class="p">(</span><span class="n">C4</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p5upsampled</span><span class="p">(</span><span class="n">P5</span><span class="p">)</span>
        <span class="n">P3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c3p3</span><span class="p">(</span><span class="n">C3</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p4upsampled</span><span class="p">(</span><span class="n">P4</span><span class="p">)</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_c2p2</span><span class="p">(</span><span class="n">C2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p3upsampled</span><span class="p">(</span><span class="n">P3</span><span class="p">)</span>
        <span class="c1"># 对融合后的特征图进行3*3卷积，得到最终的结果</span>
        <span class="n">P2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p2</span><span class="p">(</span><span class="n">P2</span><span class="p">)</span>
        <span class="n">P3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p3</span><span class="p">(</span><span class="n">P3</span><span class="p">)</span>
        <span class="n">P4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p4</span><span class="p">(</span><span class="n">P4</span><span class="p">)</span>
        <span class="n">P5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p5</span><span class="p">(</span><span class="n">P5</span><span class="p">)</span>
        <span class="c1"># 对p5进行下采样得到p6特征图</span>
        <span class="n">P6</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpn_p6</span><span class="p">(</span><span class="n">P5</span><span class="p">)</span>
        <span class="c1"># 返回最终的结果</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">P2</span><span class="p">,</span> <span class="n">P3</span><span class="p">,</span> <span class="n">P4</span><span class="p">,</span> <span class="n">P5</span><span class="p">,</span> <span class="n">P6</span><span class="p">]</span>
</code></pre></div>

<h3 id="42-rpn">4.2 RPN网络<a class="headerlink" href="#42-rpn" title="Permanent link">&para;</a></h3>
<p>经典的检测方法生成检测框都非常耗时，如OpenCV adaboost使用滑动窗口+图像金字塔生成检测框；或如R-CNN使用选择性搜索方法生成检测框。而Faster RCNN则抛弃了传统的滑动窗口和SS方法，直接使用RPN生成候选区域，能极大提升检测速度。</p>
<p><img alt="image-20200914163118758" src="../assets/image-20200914163118758.png" /></p>
<p>RPN网络分为两部分，一部分是通过softmax分类判断anchor中是否包含目标，另一部分用于计算对于anchors的偏移量，以获得精确的候选区域。而最后的Proposal层则负责综合含有目标的anchors和对应bbox回归偏移量获取候选区域，同时剔除太小和超出边界的候选区域。</p>
<h4 id="421-anchors">4.2.1 anchors<a class="headerlink" href="#421-anchors" title="Permanent link">&para;</a></h4>
<p>anchor在目标检测中表示 <strong>固定的参考框</strong> ，首先预设一组不同尺度不同长宽比的固定参考框，覆盖几乎所有位置， <strong>每个参考框负责检测与其交并比大于阈值 (训练预设值，常用0.5或0.7) 的目标</strong> ，anchor技术将检测问题转换为 <strong>"这个固定参考框中有没有目标，目标框偏离参考框多远"</strong> ，不再需要多尺度遍历滑窗，真正实现了又好又快。</p>
<p>在fasterRCNN中框出多尺度、多种长宽比的anchors,多种尺度，每个特征图中的像素点多个框。如下图所示：</p>
<p><img alt="image-20200914164908938" src="../assets/image-20200914164908938.png" /></p>
<p>由于有 FPN 网络，所以会在多个特征图中生成anchor，假设某一个特征图大小为hxw，首先会计算这个特征相对于输入图像的下采样倍数 stride：</p>
<p><img alt="image-20200917181250070" src="../assets/image-20200917181250070.png" /></p>
<p>如下图所示：</p>
<p><img alt="image-20200917181349548" src="../assets/image-20200917181349548.png" /></p>
<p>在这里每一个特征图对应一个尺度的anchor。</p>
<p>源码中anchor的生成方法：fasterRCNN/detection/core/anchor/anchor_generator.py</p>
<p>主要方法是：</p>
<ul>
<li>_generate_level_anchors：通过广播的方法生成每一个特征图的anchorbox</li>
<li>_generate_valid_flags：标记真实图像中的anchor</li>
<li>generate_pyramid_anchors:调用上述两个方法完成图像的anchor的生成</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">AnchorGenerator</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">scales</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span> 
                 <span class="n">ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> 
                 <span class="n">feature_strides</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        初始化anchor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># scales: 生成的anchor的尺度</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scales</span> <span class="o">=</span> <span class="n">scales</span>
        <span class="c1"># ratios: anchor的长宽比</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ratios</span> <span class="o">=</span> <span class="n">ratios</span>
        <span class="c1"># feature_strides: 因为fpn生成了五种特征图，在每一个特征图上移动一个位置相当于原图的大小</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feature_strides</span> <span class="o">=</span> <span class="n">feature_strides</span>

    <span class="k">def</span> <span class="nf">generate_pyramid_anchors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">img_metas</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        生成anchor</span>

<span class="sd">        参数：</span>
<span class="sd">            img_metas: [batch_size, 11]，图像的信息，包括原始图像的大小，resize的大小和输入到网络中图像的大小</span>

<span class="sd">        返回：</span>
<span class="sd">            anchors: [num_anchors, (y1, x1, y2, x2)] anchor的坐标，在原图像中的坐标</span>
<span class="sd">            valid_flags: [batch_size, num_anchors] 是否为空的标志</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 获取输入到网络中图像的大小：[1216, 1216]</span>
        <span class="n">pad_shape</span> <span class="o">=</span> <span class="n">calc_batch_padded_shape</span><span class="p">(</span><span class="n">img_metas</span><span class="p">)</span>
        <span class="c1"># 获取图像的每一个特征图的大小：[(304, 304), (152, 152), (76, 76), (38, 38), (19, 19)]</span>
        <span class="n">feature_shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pad_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">stride</span><span class="p">,</span> <span class="n">pad_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">stride</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">stride</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_strides</span><span class="p">]</span>
        <span class="c1"># 生成每一个特征图上anchor的位置信息： [277248, 4], [69312, 4], [17328, 4], [4332, 4], [1083, 4]</span>
        <span class="n">anchors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_level_anchors</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">feature_shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feature_shapes</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="c1"># 将所有的anchor串联在一个列表中：[369303, 4]</span>
        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># 获取图像非0位置的大小：(800, 1067)</span>
        <span class="n">img_shapes</span> <span class="o">=</span> <span class="n">calc_img_shapes</span><span class="p">(</span><span class="n">img_metas</span><span class="p">)</span>
        <span class="c1"># 获取anchor的非零标识</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_valid_flags</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">img_shapes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img_shapes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="c1"># 堆叠为一个一维向量</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">valid_flags</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 停止梯度计算</span>
        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="n">anchors</span><span class="p">)</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="n">valid_flags</span><span class="p">)</span>
        <span class="c1"># 返回anchor和对应非零标志</span>
        <span class="k">return</span> <span class="n">anchors</span><span class="p">,</span> <span class="n">valid_flags</span>

    <span class="k">def</span> <span class="nf">_generate_valid_flags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchors</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        移除padding位置的anchor</span>
<span class="sd">        参数：</span>
<span class="sd">            anchors: [num_anchors, (y1, x1, y2, x2)] 所有的anchor</span>
<span class="sd">            img_shape: Tuple. (height, width, channels) 非0像素点的图像的大小</span>
<span class="sd">        返回：</span>
<span class="sd">            valid_flags: [num_anchors] 返回非0位置的anchor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 计算所有anchor的中心点坐标：[369300]</span>
        <span class="n">y_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">anchors</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">anchors</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">x_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">anchors</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">anchors</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="c1"># 初始化flags为全1数组：[369300]</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># 初始化相同大小的全0数组</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># 将anchor中心点在非0区域的置为1，其他置为0</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y_center</span> <span class="o">&lt;=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">valid_flags</span><span class="p">,</span> <span class="n">zeros</span><span class="p">)</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x_center</span> <span class="o">&lt;=</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">valid_flags</span><span class="p">,</span> <span class="n">zeros</span><span class="p">)</span>
        <span class="c1"># 返回标志结果</span>
        <span class="k">return</span> <span class="n">valid_flags</span>

    <span class="k">def</span> <span class="nf">_generate_level_anchors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">feature_shape</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;生成fpn输出的某一个特征图的anchor</span>

<span class="sd">        参数：</span>
<span class="sd">            feature_shape: (height, width) 特征图大小</span>

<span class="sd">        返回：</span>
<span class="sd">            numpy.ndarray [anchors_num, (y1, x1, y2, x2)]：生成的anchor结果</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 获取对应的尺度</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scales</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>
        <span class="c1"># 获取长宽比</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ratios</span>
        <span class="c1"># 获取对应步长</span>
        <span class="n">feature_stride</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">feature_strides</span><span class="p">[</span><span class="n">level</span><span class="p">]</span>

        <span class="c1"># 获取不同长宽比下的scale</span>
        <span class="n">scales</span><span class="p">,</span> <span class="n">ratios</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">scale</span><span class="p">)],</span> <span class="n">ratios</span><span class="p">)</span>
        <span class="c1"># 尺度 [32, 32, 32]</span>
        <span class="n">scales</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">scales</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># 长宽比 [0.5, 1, 2]</span>
        <span class="n">ratios</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ratios</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># 获取不同宽高比情况下的H和w</span>
        <span class="c1"># [45, 32, 22]</span>
        <span class="n">heights</span> <span class="o">=</span> <span class="n">scales</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ratios</span><span class="p">)</span>
        <span class="c1"># [22, 32, 45]</span>
        <span class="n">widths</span> <span class="o">=</span> <span class="n">scales</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ratios</span><span class="p">)</span>

        <span class="c1"># 获取生成anchor对应的位置,假设步长为4时的结果： [0, 4, ..., 1216-4]</span>
        <span class="n">shifts_y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">feature_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">feature_stride</span><span class="p">)</span>
        <span class="n">shifts_x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">feature_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">feature_stride</span><span class="p">)</span>
        <span class="c1"># 类型转换</span>
        <span class="n">shifts_x</span><span class="p">,</span> <span class="n">shifts_y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">shifts_x</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">shifts_y</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># 获取在图像中生成anchor的位置</span>
        <span class="n">shifts_x</span><span class="p">,</span> <span class="n">shifts_y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">shifts_x</span><span class="p">,</span> <span class="n">shifts_y</span><span class="p">)</span>

        <span class="c1"># 将宽高分别相对于x,y进行广播， 得到宽高和中心点坐标</span>
        <span class="n">box_widths</span><span class="p">,</span> <span class="n">box_centers_x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">widths</span><span class="p">,</span> <span class="n">shifts_x</span><span class="p">)</span>
        <span class="n">box_heights</span><span class="p">,</span> <span class="n">box_centers_y</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">heights</span><span class="p">,</span> <span class="n">shifts_y</span><span class="p">)</span>

        <span class="c1"># 进行reshape得到anchor的中心点坐标和宽高</span>
        <span class="n">box_centers</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">box_centers_y</span><span class="p">,</span> <span class="n">box_centers_x</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">box_sizes</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">box_heights</span><span class="p">,</span> <span class="n">box_widths</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="c1"># 拼接成一维向量，并以左上角和右下角坐标的形式表示 [304x304, 3, 4] =&gt; [277448, 4]</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">box_centers</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">box_sizes</span><span class="p">,</span>
                           <span class="n">box_centers</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">box_sizes</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 返回最终的anchorbox</span>
        <span class="k">return</span> <span class="n">boxes</span>
</code></pre></div>

<p>那这些anchors是如何使用的呢？对于Conv layers特征提取得到的feature maps，为每一个点都分配这k个anchors作为初始的参考框，送入到softmax和全连接层中进行分类和回归，也就是一个二分类过程，判断anchor中是否包含目标，并对anchors进行修正。</p>
<p><img alt="image-20200914165619471" src="../assets/image-20200914165619471.png" /></p>
<h4 id="422-rpn">4.2.2 RPN分类<a class="headerlink" href="#422-rpn" title="Permanent link">&para;</a></h4>
<p>一副MxN大小的矩阵送入Faster RCNN网络后，经过backbone特征提取到RPN网络变为HxW大小的特征图。如下图所示，是RPN进行分类的网络结构：(k=9)</p>
<p><img alt="image-20200914170316205" src="../assets/image-20200914170316205.png" /></p>
<p>先做一个1x1的卷积，得到[batchsize,H,W,18]的特征图，然后进行reshape,将特征图转换为[batchsize,9xH,W,2]的特征图后，送入softmax中进行分类，得到分类结果后，再进行reshape最终得到[batchsize,H,W,18]大小的结果,18表示k=9个anchor是否包含目标的概率值。</p>
<p><img alt="image-20200914170637421" src="../assets/image-20200914170637421.png" /></p>
<h4 id="423-rpn">4.2.3 RPN回归<a class="headerlink" href="#423-rpn" title="Permanent link">&para;</a></h4>
<p>RPN回归的结构如下图所示：(k=9)</p>
<p><img alt="image-20200914173518689" src="../assets/image-20200914173518689.png" /></p>
<p>经过该卷积输出特征图为为[1,  H, W,4x9]，这里相当于feature maps每个点都有9个anchors，每个anchors又都有4个用于回归的:</p>
<p><img alt="image-20200914173617857" src="../assets/image-20200914173617857.png" /></p>
<p>变换量。</p>
<p>该变换量预测的是anchor与真实值之间的平移量和尺度因子：</p>
<p><img alt="image-20200914174033826" src="../assets/image-20200914174033826.png" /></p>
<p>坐标变换的源码为：fasterRCNN/detection/core/bbox/transforms.py</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">bbox2delta</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">gt_box</span><span class="p">,</span> <span class="n">target_means</span><span class="p">,</span> <span class="n">target_stds</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;计算box到gtbox的修正值.</span>
<span class="sd">    参数</span>

<span class="sd">        box: [..., (y1, x1, y2, x2)] : 要修正的box</span>
<span class="sd">        gt_box: [..., (y1, x1, y2, x2)] : GT值</span>
<span class="sd">        target_means: [4] :均值</span>
<span class="sd">        target_stds: [4]:方差</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># 转化为tensor</span>
    <span class="n">target_means</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span>
        <span class="n">target_means</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">target_stds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span>
        <span class="n">target_stds</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># 类型转换</span>
    <span class="n">box</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">box</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">gt_box</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">gt_box</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># 获取box的中心点坐标和宽高</span>
    <span class="n">height</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">width</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">center_y</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">height</span>
    <span class="n">center_x</span> <span class="o">=</span> <span class="n">box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span>
    <span class="c1"># 获取Gtbox的中心点坐标和宽高</span>
    <span class="n">gt_height</span> <span class="o">=</span> <span class="n">gt_box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">gt_box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">gt_width</span> <span class="o">=</span> <span class="n">gt_box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">gt_box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">gt_center_y</span> <span class="o">=</span> <span class="n">gt_box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_height</span>
    <span class="n">gt_center_x</span> <span class="o">=</span> <span class="n">gt_box</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gt_width</span>
    <span class="c1"># 计算两者之间的平移值和尺度变换</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_center_y</span> <span class="o">-</span> <span class="n">center_y</span><span class="p">)</span> <span class="o">/</span> <span class="n">height</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">gt_center_x</span> <span class="o">-</span> <span class="n">center_x</span><span class="p">)</span> <span class="o">/</span> <span class="n">width</span>
    <span class="n">dh</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gt_height</span> <span class="o">/</span> <span class="n">height</span><span class="p">)</span>
    <span class="n">dw</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gt_width</span> <span class="o">/</span> <span class="n">width</span><span class="p">)</span>
    <span class="c1"># 组成一维向量</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">dy</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dh</span><span class="p">,</span> <span class="n">dw</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 标准化</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span><span class="n">delta</span> <span class="o">-</span> <span class="n">target_means</span><span class="p">)</span> <span class="o">/</span> <span class="n">target_stds</span>
    <span class="c1"># 返回结果</span>
    <span class="k">return</span> <span class="n">delta</span>
</code></pre></div>

<p>RPN的分类和回归的源码如下：fasterRCNN/detection/models/rpn_heads/rpn_head.py</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">RPNHead</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    完成RPN网络中的相关操作</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">anchor_scales</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">),</span> 
                 <span class="n">anchor_ratios</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> 
                 <span class="n">anchor_feature_strides</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">),</span>
                 <span class="n">proposal_count</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> 
                 <span class="n">nms_threshold</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> 
                 <span class="n">target_means</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> 
                 <span class="n">target_stds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span> 
                 <span class="n">num_rpn_deltas</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span>
                 <span class="n">positive_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">pos_iou_thr</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                 <span class="n">neg_iou_thr</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwags</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        RPN网络结构，如下所示：</span>

<span class="sd">                                      / - rpn_cls 分类(1x1 conv)</span>
<span class="sd">        输入 - rpn_conv 卷积(3x3 conv) -</span>
<span class="sd">                                      \ - rpn_reg 回归(1x1 conv)</span>

<span class="sd">        参数</span>
<span class="sd">            anchor_scales: anchorbox的面积，相对于原图像像素的</span>
<span class="sd">            anchor_ratios: anchorbox的长宽比</span>
<span class="sd">            anchor_feature_strides: 生成anchor的步长，相对于原图像素的</span>
<span class="sd">            proposal_count:RPN最后生成的候选区域的个数，经过非极大值抑制</span>
<span class="sd">            nms_threshold: 对RPN生成的候选区域进行NMS的参数阈值</span>
<span class="sd">            target_means: [4] Bounding box refinement mean.</span>
<span class="sd">            target_stds: [4] Bounding box refinement standard deviation.</span>
<span class="sd">            num_rpn_deltas: int.</span>
<span class="sd">            positive_fraction: float.</span>
<span class="sd">            pos_iou_thr: 与GT的IOU大于该值的anchor为正例</span>
<span class="sd">            neg_iou_thr: 与GT的IOU小于该值的anchor为负例</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RPNHead</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwags</span><span class="p">)</span>
        <span class="c1"># 参数初始化</span>
        <span class="c1"># RPN最后生成的候选区域的个数，经过非极大值抑制</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proposal_count</span> <span class="o">=</span> <span class="n">proposal_count</span>
        <span class="c1"># 对RPN生成的候选区域进行NMS的参数阈值</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nms_threshold</span> <span class="o">=</span> <span class="n">nms_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_means</span> <span class="o">=</span> <span class="n">target_means</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stds</span> <span class="o">=</span> <span class="n">target_stds</span>
        <span class="c1"># 调用anchor生成器生成对应的anchor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">generator</span> <span class="o">=</span> <span class="n">anchor_generator</span><span class="o">.</span><span class="n">AnchorGenerator</span><span class="p">(</span>
            <span class="n">scales</span><span class="o">=</span><span class="n">anchor_scales</span><span class="p">,</span> 
            <span class="n">ratios</span><span class="o">=</span><span class="n">anchor_ratios</span><span class="p">,</span> 
            <span class="n">feature_strides</span><span class="o">=</span><span class="n">anchor_feature_strides</span><span class="p">)</span>
        <span class="c1"># 将anchor划分为正负样本</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">anchor_target</span> <span class="o">=</span> <span class="n">anchor_target</span><span class="o">.</span><span class="n">AnchorTarget</span><span class="p">(</span>
            <span class="n">target_means</span><span class="o">=</span><span class="n">target_means</span><span class="p">,</span> 
            <span class="n">target_stds</span><span class="o">=</span><span class="n">target_stds</span><span class="p">,</span>
            <span class="n">num_rpn_deltas</span><span class="o">=</span><span class="n">num_rpn_deltas</span><span class="p">,</span>
            <span class="n">positive_fraction</span><span class="o">=</span><span class="n">positive_fraction</span><span class="p">,</span>
            <span class="n">pos_iou_thr</span><span class="o">=</span><span class="n">pos_iou_thr</span><span class="p">,</span>
            <span class="n">neg_iou_thr</span><span class="o">=</span><span class="n">neg_iou_thr</span><span class="p">)</span>
        <span class="c1"># 设置RPN网络的分类和回归损失</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_class_loss</span> <span class="o">=</span> <span class="n">losses</span><span class="o">.</span><span class="n">rpn_class_loss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_bbox_loss</span> <span class="o">=</span> <span class="n">losses</span><span class="o">.</span><span class="n">rpn_bbox_loss</span>


        <span class="c1"># 3*3卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_conv_shared</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span>
                                             <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> 
                                             <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rpn_conv_shared&#39;</span><span class="p">)</span>
        <span class="c1"># 1*1卷积 分类 每一个anchor分为2类</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_class_raw</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">anchor_ratios</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                           <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> 
                                           <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rpn_class_raw&#39;</span><span class="p">)</span>
        <span class="c1"># 1*1卷积 回归 每一个anchor的回归结果</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rpn_delta_pred</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">anchor_ratios</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                           <span class="n">kernel_initializer</span><span class="o">=</span><span class="s1">&#39;he_normal&#39;</span><span class="p">,</span> 
                                           <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rpn_bbox_pred&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        定义前向传播过程</span>
<span class="sd">        参数：</span>
<span class="sd">            inputs: [batch_size, feat_map_height, feat_map_width, channels] </span>
<span class="sd">                FPN输出的一个特征图</span>

<span class="sd">        返回：</span>
<span class="sd">            rpn_class_logits: [batch_size, num_anchors, 2] 分类结果，以logits表示</span>
<span class="sd">            rpn_probs: [batch_size, num_anchors, 2] 分类结果，经softmax之后的概率表示形式</span>
<span class="sd">            rpn_deltas: [batch_size, num_anchors, 4] 回归结果，anchor的位置信息</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 输出结果</span>
        <span class="n">layer_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># 遍历输入中的每一特征图</span>
        <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="c1"># 3*3 卷积，假设特征图大小为：(1, 304, 304, 256)</span>
            <span class="n">shared</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpn_conv_shared</span><span class="p">(</span><span class="n">feat</span><span class="p">)</span>
            <span class="c1"># 激活：(1, 304, 304, 256)</span>
            <span class="n">shared</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span>

            <span class="c1"># 分类过程</span>
            <span class="c1"># 1*1卷积：输出大小为(1, 304, 304, 6)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpn_class_raw</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span>
            <span class="c1"># reshape:(1, 277248, 2)</span>
            <span class="n">rpn_class_logits</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="c1"># softmax进行分类：(1, 277248, 2)，一共有277248个anchor，每个anchor有2个分类结果</span>
            <span class="n">rpn_probs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">rpn_class_logits</span><span class="p">)</span>

            <span class="c1"># 回归过程</span>
            <span class="c1"># 1*1 卷积，输出大小为(1, 304, 304, 12)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rpn_delta_pred</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span>
            <span class="c1"># reshape:(1, 277248, 4),一共有277248个anchor，每个anchor有4个位置信息</span>
            <span class="n">rpn_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

            <span class="c1"># 将网络的分类和输出结果存放在layer_outputs</span>
            <span class="n">layer_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">rpn_class_logits</span><span class="p">,</span> <span class="n">rpn_probs</span><span class="p">,</span> <span class="n">rpn_deltas</span><span class="p">])</span>
            <span class="c1"># 每一次迭代输出结果的大小为：</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            (1, 277248, 2) (1, 277248, 2) (1, 277248, 4)</span>
<span class="sd">            (1, 69312, 2) (1, 69312, 2) (1, 69312, 4)</span>
<span class="sd">            (1, 17328, 2) (1, 17328, 2) (1, 17328, 4)</span>
<span class="sd">            (1, 4332, 2) (1, 4332, 2) (1, 4332, 4)</span>
<span class="sd">            (1, 1083, 2) (1, 1083, 2) (1, 1083, 4)</span>

<span class="sd">            &quot;&quot;&quot;</span>

        <span class="c1"># 将输出结果转换为列表</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">layer_outputs</span><span class="p">))</span>
        <span class="c1"># 遍历输出，将不同特征图中同一类别的输出结果串联在一起</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">o</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span>
        <span class="c1"># 获取每一种输出：5个特征图的输出大小为：(1, 369303, 2) (1, 369303, 2) (1, 369303, 4)</span>
        <span class="n">rpn_class_logits</span><span class="p">,</span> <span class="n">rpn_probs</span><span class="p">,</span> <span class="n">rpn_deltas</span> <span class="o">=</span> <span class="n">outputs</span>

        <span class="c1"># 返回输出结果</span>
        <span class="k">return</span> <span class="n">rpn_class_logits</span><span class="p">,</span> <span class="n">rpn_probs</span><span class="p">,</span> <span class="n">rpn_deltas</span>
</code></pre></div>

<h4 id="424-proposal-layer">4.2.4 Proposal Layer<a class="headerlink" href="#424-proposal-layer" title="Permanent link">&para;</a></h4>
<p>Proposal Layer负责综合所有 <img alt="[公式]" src="https://www.zhihu.com/equation?tex=%5Bd_%7Bx%7D%28A%29%2Cd_%7By%7D%28A%29%2Cd_%7Bw%7D%28A%29%2Cd_%7Bh%7D%28A%29%5D" /> 变换量和包含目标的anchors，计算出候选区域proposal，送入后续RoI Pooling Layer。</p>
<p>Proposal Layer有3个输入：anchors分类器结果，对应的bbox reg的 <img alt="[公式]" src="https://www.zhihu.com/equation?tex=%5Bd_%7Bx%7D%28A%29%2Cd_%7By%7D%28A%29%2Cd_%7Bw%7D%28A%29%2Cd_%7Bh%7D%28A%29%5D" /> 变换量，以及im_info；另外还有参数feat_stride，用于计算anchor的步长。</p>
<p>Proposal Layer 完成以下处理：</p>
<ol>
<li>生成anchors，利用<img alt="[公式]" src="https://www.zhihu.com/equation?tex=%5Bd_%7Bx%7D%28A%29%2Cd_%7By%7D%28A%29%2Cd_%7Bw%7D%28A%29%2Cd_%7Bh%7D%28A%29%5D" />对所有的anchors做bbox regression回归</li>
<li>按照输入的positive softmax scores由大到小排序anchors，提取前pre_nms_topN(e.g. 6000)个anchors，即提取修正位置后的positive anchors</li>
<li>限定超出图像边界的positive anchors为图像边界，防止后续roi pooling时proposal超出图像边界。</li>
</ol>
<p><img alt="image-20200914174724293" src="../assets/image-20200914174724293.png" /></p>
<ol>
<li>
<p>剔除尺寸非常小的positive anchors</p>
</li>
<li>
<p>对剩余的positive anchors进行NMS（nonmaximum suppression）</p>
</li>
<li>
<p>Proposal Layer的输出是对应MxN输入图像尺度的坐标值[x1, y1, x2, y2]。</p>
</li>
</ol>
<p>到此RPN网络的工作就结束了。</p>
<p>该部分的源码在：fasterRCNN/detection/models/rpn_heads/rpn_head.py</p>
<div class="highlight"><pre><span></span><code> <span class="k">def</span> <span class="nf">_get_proposals_single</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                              <span class="n">rpn_probs</span><span class="p">,</span> 
                              <span class="n">rpn_deltas</span><span class="p">,</span> 
                              <span class="n">anchors</span><span class="p">,</span> 
                              <span class="n">valid_flags</span><span class="p">,</span> 
                              <span class="n">img_shape</span><span class="p">,</span> 
                              <span class="n">with_probs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        计算候选区域结果</span>

<span class="sd">        参数：</span>
<span class="sd">            rpn_probs: [num_anchors] anchor是目标的概率值</span>
<span class="sd">            rpn_deltas: [num_anchors, (dy, dx, log(dh), log(dw))] 回归得到的位置信息，对anchor进行修正</span>
<span class="sd">            anchors: [num_anchors, (y1, x1, y2, x2)] anchor的位置</span>
<span class="sd">            valid_flags: [num_anchors] anchor属于图像位置的标记信息</span>
<span class="sd">            img_shape: np.ndarray. [2]. (img_height, img_width) 图像的大小</span>
<span class="sd">            with_probs: bool. 是否输出分类结果</span>

<span class="sd">        返回</span>
<span class="sd">            proposals:  返回候选区域的列表</span>
<span class="sd">            若with_probs = False，则返回：[num_proposals, (y1, x1, y2, x2)]</span>
<span class="sd">                若with_probs = True，则返回：[num_proposals, (y1, x1, y2, x2, score)]</span>
<span class="sd">                在这里num_proposals不会大于proposal_count</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 图像的高宽</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">img_shape</span>

        <span class="c1"># 将anchor的标记信息转换为布尔型, int =&gt; bool</span>
        <span class="n">valid_flags</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">valid_flags</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="c1"># 将无用的anchor过滤 ，并对分类和回归结果进行处理[369303] =&gt; [215169], respectively</span>
        <span class="n">rpn_probs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">rpn_probs</span><span class="p">,</span> <span class="n">valid_flags</span><span class="p">)</span>
        <span class="n">rpn_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">rpn_deltas</span><span class="p">,</span> <span class="n">valid_flags</span><span class="p">)</span>
        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">valid_flags</span><span class="p">)</span>

        <span class="c1"># 至多6000个结果会进行后续操作 min(6000, 215169) =&gt; 6000</span>
        <span class="n">pre_nms_limit</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">6000</span><span class="p">,</span> <span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># 获取至多6000个分类概率最高的anchor的索引</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="n">rpn_probs</span><span class="p">,</span> <span class="n">pre_nms_limit</span><span class="p">,</span> <span class="nb">sorted</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span>
        <span class="c1"># 根据得到的索引值获取对应的分类，回归和anchor [215169] =&gt; [6000]</span>
        <span class="n">rpn_probs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">rpn_probs</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>
        <span class="n">rpn_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">rpn_deltas</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>
        <span class="n">anchors</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span>

        <span class="c1"># 利用回归得到的结果对anchor进行修正,  [6000, 4]</span>
        <span class="n">proposals</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">delta2bbox</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">rpn_deltas</span><span class="p">,</span> 
                                          <span class="bp">self</span><span class="o">.</span><span class="n">target_means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stds</span><span class="p">)</span>
        <span class="c1"># 若修正后的结果超出图像范围则进行裁剪, [6000, 4]</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">proposals</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">bbox_clip</span><span class="p">(</span><span class="n">proposals</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span>

        <span class="c1"># 对坐标值进行归一化, (y1, x1, y2, x2)</span>
        <span class="n">proposals</span> <span class="o">=</span> <span class="n">proposals</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># 进行NMS，获取最终大概2000个候选区域: [2000]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">non_max_suppression</span><span class="p">(</span>
            <span class="n">proposals</span><span class="p">,</span> <span class="n">rpn_probs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">proposal_count</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nms_threshold</span><span class="p">)</span>
        <span class="n">proposals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">proposals</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="c1"># [2000, 4]</span>
        <span class="c1"># 若要返回分类结果，则获取对应的分类值进行返回</span>
        <span class="k">if</span> <span class="n">with_probs</span><span class="p">:</span>
            <span class="n">proposal_probs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">rpn_probs</span><span class="p">,</span> <span class="n">indices</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">proposals</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">proposals</span><span class="p">,</span> <span class="n">proposal_probs</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 返回候选区域</span>
        <span class="k">return</span> <span class="n">proposals</span>
</code></pre></div>

<h3 id="43-roipooling">4.3 ROIPooling<a class="headerlink" href="#43-roipooling" title="Permanent link">&para;</a></h3>
<p>RoI Pooling层则负责收集proposal，并计算出 feature maps的候选区域，送入后续网络。</p>
<p><img alt="image-20201021100152187" src="../assets/image-20201021100152187.png" /></p>
<p>从网络架构中可以看出Rol pooling层有2个输入：</p>
<ol>
<li>CNN提取的feature maps</li>
<li>RPN输出的候选区域proposal boxes（大小各不相同）</li>
</ol>
<p>RoIpooling使用最大池化将任何有效的RoI区域内的特征转换成具有pool_H×pool_W的固定空间范围的小feature map，其中pool_H和pool_W是超参数，比如设置为7x7, 它们独立于任何特定的RoI,如下图所示21·  </p>
<p><img alt="image-20201021100421465" src="../assets/image-20201021100421465.png" /></p>
<p>RoI Pooling 的作用过程，如下图所示：</p>
<p><img alt="image-20201021101351332" src="../assets/image-20201021101351332.png" /></p>
<ul>
<li>由于RPN网络输出的proposal是对应MxN尺度的，所以首先使用spatial_scale参数将其映射回特征提取后（HxW）大小的feature map尺度；</li>
<li>再将每个proposal对应的feature map区域水平分为 <img alt="[公式]" src="https://www.zhihu.com/equation?tex=%5Ctext%7Bpooled_w%7D%5Ctimes+%5Ctext%7Bpooled_h%7D" /> 的网格；</li>
<li>对网格的每一份都进行max pooling处理。</li>
</ul>
<p>这样处理后，即使大小不同的proposal输出结果都是 <img alt="[公式]" src="https://www.zhihu.com/equation?tex=%5Ctext%7Bpooled_w%7D%5Ctimes+%5Ctext%7Bpooled_h%7D" /> 固定大小，实现了固定长度输出,送入后续网络中进行处理。</p>
<p>在实现过程中，FPN网络产生了多个尺度特征图，那候选区域要映射到哪个特征图中呢？</p>
<p><img alt="image-20201021101441266" src="../assets/image-20201021101441266.png" /></p>
<p>在这里，不同尺度的ROI使用不同特征层作为ROI pooling层的输入，大尺度ROI就用后面一些的金字塔层，比如P5；小尺度ROI就用前面一点的特征层，比如P3，我们使用下面的公式确定ROI所在的特征层：</p>
<p><img alt="image-20201021102107570" src="../assets/image-20201021102107570.png" /></p>
<p>其中，224是ImageNet的标准输入，k0是基准值，设置为4，w和h是ROI区域的长和宽，假设ROI是112x112的大小，那么k = k0-1 = 4-1 = 3，意味着该ROI应该使用P3的特征层。k值会做取整处理，防止结果不是整数，而且为了保证k值在2-5之间，还会做截断处理。 </p>
<p>源码在:fasterRCNN/detection/models/roi_extractors/roi_align.py</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">PyramidROIAlign</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">Layer</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_shape</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        在多个特征图上完成ROIPooling</span>

<span class="sd">        参数：</span>
<span class="sd">            pool_shape: (height, width)指明pooling之后输出的大小</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">PyramidROIAlign</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pool_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>

        <span class="c1"># 获取输入中的roi区域，特征图和图像的元信息</span>
        <span class="n">rois_list</span><span class="p">,</span> <span class="n">feature_map_list</span><span class="p">,</span> <span class="n">img_metas</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="c1"># 获取输入图像的大小</span>
        <span class="n">pad_shapes</span> <span class="o">=</span> <span class="n">calc_pad_shapes</span><span class="p">(</span><span class="n">img_metas</span><span class="p">)</span>
        <span class="c1"># 图像的尺度：1216*1216</span>
        <span class="n">pad_areas</span> <span class="o">=</span> <span class="n">pad_shapes</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">pad_shapes</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># 获取图像中ROI的类别data:[2000]</span>
        <span class="n">num_rois_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">rois</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">rois</span> <span class="ow">in</span> <span class="n">rois_list</span><span class="p">]</span>
        <span class="c1"># 获取图像中ROI的索引</span>
        <span class="n">roi_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span>
            <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rois_list</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rois_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span>
        <span class="p">)</span> <span class="c1">#[0.....], shape:[2000]</span>
        <span class="c1"># 获取对于每一个ROI的图像大小</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="c1">#              range(1)                               range(2000)</span>
            <span class="p">[</span><span class="n">pad_areas</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pad_areas</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rois_list</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
        <span class="p">)</span><span class="c1">#[1216*1216, 1216*1216,...], shape:[2000]</span>

        <span class="c1"># ROI</span>
        <span class="n">rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rois_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># [2000, 4]</span>

        <span class="c1"># 获取每一个ROI对应的坐标和宽高</span>
        <span class="n">y1</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># 4 of [2000, 1]</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span> <span class="c1"># [2000, 1]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span> <span class="c1"># [2000, 1]</span>

        <span class="c1"># 将每一个ROI分配到对应的特征图上</span>
        <span class="n">roi_level</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="c1"># [2000]</span>
                    <span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">((</span><span class="mf">224.0</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">areas</span> <span class="o">*</span> <span class="mf">1.0</span><span class="p">)),</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
                    <span class="p">)</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">roi_level</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span> <span class="c1"># [2000], clamp to [2-5]</span>
            <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">roi_level</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)))</span>
        <span class="c1"># roi_level will indicates which level of feature to use</span>


        <span class="c1"># 遍历所有的特征图，进行ROIpooling/ROIAlign</span>
        <span class="n">pooled_rois</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">roi_to_level</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">)):</span> <span class="c1"># 2,3,4,5</span>
            <span class="c1"># 找到ROI对应的特征图尺度</span>
            <span class="n">ix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">roi_level</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>
            <span class="c1"># 获取到对应的ROI区域</span>
            <span class="n">level_rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">rois</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span> 

            <span class="c1"># 获取ROI对应的索引</span>
            <span class="n">level_roi_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">roi_indices</span><span class="p">,</span> <span class="n">ix</span><span class="p">)</span> 

            <span class="c1"># Keep track of which roi is mapped to which level</span>
            <span class="n">roi_to_level</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span>

            <span class="c1"># 不进行梯度更新</span>
            <span class="n">level_rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="n">level_rois</span><span class="p">)</span>
            <span class="n">level_roi_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="n">level_roi_indices</span><span class="p">)</span>

            <span class="c1"># 进行ROI_align,是ROIpooling的改进版本(在MaskRCNN中介绍)</span>
            <span class="n">pooled_rois</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">crop_and_resize</span><span class="p">(</span>
                <span class="n">feature_map_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">level_rois</span><span class="p">,</span> <span class="n">level_roi_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_shape</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="s2">&quot;bilinear&quot;</span><span class="p">))</span> 
        <span class="p">[</span>
        <span class="c1"># 将特征拼接在一起 [2000, 7, 7, 256]</span>
        <span class="n">pooled_rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pooled_rois</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># .....</span>
        <span class="c1"># 获取 2000个候选区域 2000 of [7, 7, 256]</span>
        <span class="n">pooled_rois_list</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pooled_rois</span><span class="p">,</span> <span class="n">num_rois_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pooled_rois_list</span>
</code></pre></div>

<h3 id="44-classifierregression">4.4 Classifier+Regression<a class="headerlink" href="#44-classifierregression" title="Permanent link">&para;</a></h3>
<p>Classifier+Regression部分利用获得的候选区域的特征图，通过全连接层与softmax计算每个候选区域proposal具体属于的类别（如人，车，电视等），输出cls_prob概率；同时再次利用bounding box regression获得每个proposal的位置偏移量bbox_pred，用于回归更加精确的目标检测框。Classifier部分网络结构如下所示：</p>
<p><img alt="image-20200914175906233" src="../assets/image-20200914175906233.png" /></p>
<p>从RoI Pooling获取到7x7=49大小的特征图后，送入后续网络，可以看到做了如下2件事：</p>
<ol>
<li>通过全连接和softmax对proposals进行分类</li>
<li>再次对proposals进行bounding box regression，获取更高精度的rect box</li>
</ol>
<p>源码如下：fasterRCNN/detection/models/bbox_heads/bbox_head.py</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">BBoxHead</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">keras</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">,</span> 
                 <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
                 <span class="n">target_means</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> 
                 <span class="n">target_stds</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">),</span>
                 <span class="n">min_confidence</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                 <span class="n">nms_threshold</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span>
                 <span class="n">max_instances</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwags</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BBoxHead</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwags</span><span class="p">)</span>
        <span class="c1"># 类别个数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">=</span> <span class="n">num_classes</span>
        <span class="c1"># ROIpooling的尺寸</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pool_size</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">pool_size</span><span class="p">)</span>
        <span class="c1"># 均值</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_means</span> <span class="o">=</span> <span class="n">target_means</span>
        <span class="c1"># 标准差</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_stds</span> <span class="o">=</span> <span class="n">target_stds</span>
        <span class="c1"># 最小的置信度</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_confidence</span> <span class="o">=</span> <span class="n">min_confidence</span>
        <span class="c1"># NMS尺度</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nms_threshold</span> <span class="o">=</span> <span class="n">nms_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_instances</span> <span class="o">=</span> <span class="n">max_instances</span>
        <span class="c1"># 损失函数</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_loss</span> <span class="o">=</span> <span class="n">losses</span><span class="o">.</span><span class="n">rcnn_class_loss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_bbox_loss</span> <span class="o">=</span> <span class="n">losses</span><span class="o">.</span><span class="n">rcnn_bbox_loss</span>
        <span class="c1"># 分类卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_conv1</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pool_size</span><span class="p">,</span> 
                                              <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rcnn_class_conv1&#39;</span><span class="p">)</span>
        <span class="c1"># 分类BN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_bn1</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;rcnn_class_bn1&#39;</span><span class="p">)</span>
        <span class="c1"># 分类卷积</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_conv2</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> 
                                              <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rcnn_class_conv2&#39;</span><span class="p">)</span>
        <span class="c1"># BN层</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_bn2</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">BatchNormalization</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;rcnn_class_bn2&#39;</span><span class="p">)</span>
        <span class="c1"># 分类</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_logits</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rcnn_class_logits&#39;</span><span class="p">)</span>
        <span class="c1"># 回归</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_delta_fc</span> <span class="o">=</span> <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">num_classes</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;rcnn_bbox_fc&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        参数：</span>
<span class="sd">            pooled_rois_list: List of [num_rois, pool_size, pool_size, channels] rpn生成的候选区域</span>

<span class="sd">        返回：</span>
<span class="sd">            rcnn_class_logits_list:  [num_rois, num_classes] 分类的logits</span>
<span class="sd">            rcnn_probs_list: List of [num_rois, num_classes] 分类的损失</span>
<span class="sd">            rcnn_deltas_list: List of [num_rois, num_classes, (dy, dx, log(dh), log(dw))] 回归结果</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">pooled_rois_list</span> <span class="o">=</span> <span class="n">inputs</span>
        <span class="n">num_pooled_rois_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">pooled_rois</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">pooled_rois</span> <span class="ow">in</span> <span class="n">pooled_rois_list</span><span class="p">]</span>
        <span class="n">pooled_rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">pooled_rois_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 卷积+BN+relu</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_conv1</span><span class="p">(</span><span class="n">pooled_rois</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_bn1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 卷积+BN+relu</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_conv2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_bn2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="n">training</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># flatten</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 分类结果</span>
        <span class="n">logits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_class_logits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># 分类概率</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">logits</span><span class="p">)</span>
        <span class="c1"># 回归结果</span>
        <span class="n">deltas</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcnn_delta_fc</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>

        <span class="c1"># 分类logits</span>
        <span class="n">rcnn_class_logits_list</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">logits</span><span class="p">,</span> <span class="n">num_pooled_rois_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 分类概率</span>
        <span class="n">rcnn_probs_list</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">num_pooled_rois_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 回归结果</span>
        <span class="n">rcnn_deltas_list</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">num_pooled_rois_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 结果返回</span>
        <span class="k">return</span> <span class="n">rcnn_class_logits_list</span><span class="p">,</span> <span class="n">rcnn_probs_list</span><span class="p">,</span> <span class="n">rcnn_deltas_list</span>
</code></pre></div>

<p>到这我们就完成了整个网络的介绍。</p>
<h3 id="45-fasterrcnn">4.5 FasterRCNN的训练<a class="headerlink" href="#45-fasterrcnn" title="Permanent link">&para;</a></h3>
<p>Faster R-CNN的训练分为两部分，即RPN网络和检测网络fastRCNN的训练：</p>
<p><img alt="image-20200914180529313" src="../assets/image-20200914180529313.png" /></p>
<p>整个训练过程分为四步：</p>
<ul>
<li>第一步：RPN网络的训练，使用ImageNet预训练的模型初始化，并端到端微调用于区域建议任务。</li>
<li>第二步：利用第一步的RPN生成的建议框，由Fast R-CNN训练一个单独的检测网络，这个检测网络同样是由ImageNet预训练的模型初始化的，这时候两个网络还没有共享卷积层。</li>
<li>第三步：用检测网络初始化RPN训练，但是固定共享的卷积层，并且只微调RPN独有的层，现在两个网络共享卷积层了。</li>
<li>第四步：保持共享的卷积层固定，微调Fast R-CNN的fc层。这样，两个网络共享相同的卷积层，构成一个统一的网络。</li>
</ul>
<p><img alt="image-20200914180732315" src="../assets/image-20200914180732315.png" /></p>
<p>接下来我们分别介绍各个训练步骤：</p>
<h4 id="451-rpn">4.5.1 RPN网络的训练<a class="headerlink" href="#451-rpn" title="Permanent link">&para;</a></h4>
<p>RPN网络的作用从众多的anchors中提取包含目标的，并且经过回归调整的候选区域。为了训练RPN，给每个anchor分配是否包含目标的标签，也就是正负样本的标记，然后进行训练。</p>
<h5 id="1_1">1、正负样本标记<a class="headerlink" href="#1_1" title="Permanent link">&para;</a></h5>
<ul>
<li>与真实框ground truth（GT）交并比IOU大于0.7的anchor是正样本，即anchor中包含目标</li>
<li>与真实框ground truth（GT）交并比IOU小于0.3的anchor是负样本，即anchor中不包含目标</li>
<li>其他的anchor舍弃，不参与网络的训练</li>
</ul>
<p>该部分源码在：fasterRCNN/detection/core/anchor/anchor_target.py</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_build_single_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anchors</span><span class="p">,</span> <span class="n">valid_flags</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">gt_class_ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        计算每幅图像的目标值</span>
<span class="sd">        参数：</span>
<span class="sd">            anchors: [num_anchors, (y1, x1, y2, x2)] anchor的位置信息</span>
<span class="sd">            valid_flags: [num_anchors] anchor的表示</span>
<span class="sd">            gt_class_ids: [num_gt_boxes] 真实值的类别</span>
<span class="sd">            gt_boxes: [num_gt_boxes, (y1, x1, y2, x2)] 真实框的位置</span>
<span class="sd">        返回：</span>
<span class="sd">            target_matchs: [num_anchors] anchor是正负样本</span>
<span class="sd">            target_deltas: [num_rpn_deltas, (dy, dx, log(dh), log(dw))] </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 删除为0的真实框</span>
        <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">trim_zeros</span><span class="p">(</span><span class="n">gt_boxes</span><span class="p">)</span>
        <span class="c1"># 初始化全0数组，存储anchor的分类结果</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># 计算anchor与gt之间的交并比 326393 vs 10 =&gt; [326393, 10]</span>
        <span class="n">overlaps</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">compute_overlaps</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">)</span>

        <span class="c1"># 1.设置负样本</span>
        <span class="c1"># 获取每一个anchor与各个GT交并比的最大值及其索引</span>
        <span class="n">anchor_iou_argmax</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">overlaps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">anchor_iou_max</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">overlaps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># 选择 IOU &lt; 0.3 的 anchor 为 background，标签为 -1</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">anchor_iou_max</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">neg_iou_thr</span><span class="p">,</span> 
                                 <span class="o">-</span><span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">target_matchs</span><span class="p">)</span>

        <span class="c1"># 过滤掉pad区域的anchor</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">valid_flags</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                                 <span class="n">target_matchs</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">))</span>

        <span class="c1"># 2、选择 IOU &gt; 0.7 的 anchor 为 foreground，标签为 1</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">anchor_iou_max</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_iou_thr</span><span class="p">,</span> 
                                 <span class="n">tf</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">anchors</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">target_matchs</span><span class="p">)</span>

        <span class="c1"># 3、为每一GT分配一个anchor：不考虑IOU的大小</span>
        <span class="c1"># 选择与每一个GT交并比最大的anchor索引 ：[N_gt_boxes]</span>
        <span class="n">gt_iou_argmax</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">overlaps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 将交并比最大的设置为正样本</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">scatter_update</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">),</span> <span class="n">gt_iou_argmax</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 采样获取正负样本，主要不要使正样本比例超过一半</span>
        <span class="c1"># [N_pos_anchors, 1], [15, 1]</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># 压缩成一个一维向量 [15]</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 计算真实正样本个数与所需样本个数之间的差值</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rpn_deltas</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_fraction</span><span class="p">)</span>
        <span class="c1"># 若差值大于0，说明有足够的正样本</span>
        <span class="k">if</span> <span class="n">extra</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 将多余的正样本的标识置为0</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ids</span><span class="p">)[:</span><span class="n">extra</span><span class="p">]</span>
            <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">scatter_update</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 获取负样本</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># [213748, 1]</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 获取负样本个数与所需负样本个数之间的差值</span>
        <span class="n">extra</span> <span class="o">=</span> <span class="n">ids</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rpn_deltas</span> <span class="o">-</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)))</span>
        <span class="c1"># 若差值大于0，则说明有足够的负样本</span>
        <span class="k">if</span> <span class="n">extra</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># 将多余的负样本置为0</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ids</span><span class="p">)[:</span><span class="n">extra</span><span class="p">]</span>
            <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">scatter_update</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 这时我们就有256个anchor,分别包含正负样本.</span>

        <span class="c1"># 对于每一个正样本，计算其对应的坐标修正值</span>
        <span class="c1"># 获取正样本的索引</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># [15]</span>
        <span class="c1"># 获取正样本的anchor</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">anchors</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
        <span class="c1"># 获取anchor对应的gt的index</span>
        <span class="n">anchor_idx</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">anchor_iou_argmax</span><span class="p">,</span> <span class="n">ids</span><span class="p">)</span>
        <span class="c1"># 获取gt</span>
        <span class="n">gt</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">gt_boxes</span><span class="p">,</span> <span class="n">anchor_idx</span><span class="p">)</span>
        <span class="c1"># 计算anchor到gt的修正坐标。</span>
        <span class="n">target_deltas</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">bbox2delta</span><span class="p">(</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">gt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stds</span><span class="p">)</span>
        <span class="c1"># 获取负样本的个数</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rpn_deltas</span> <span class="o">-</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 目标值，正样本的目标值是偏移，负样本的目标值是0</span>
        <span class="n">target_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">padding</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>

        <span class="k">return</span> <span class="n">target_matchs</span><span class="p">,</span> <span class="n">target_deltas</span>
</code></pre></div>

<h5 id="2rpn">2、RPN网络的损失函数<a class="headerlink" href="#2rpn" title="Permanent link">&para;</a></h5>
<p>RPN网络的损失函数是：</p>
<p><img alt="image-20200915095837059" src="../assets/image-20200915095837059.png" /></p>
<p>其中</p>
<ul>
<li>
<p><span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>表示anchor的索引</p>
</li>
<li>
<p><span><span class="MathJax_Preview">p_i</span><script type="math/tex">p_i</script></span>是第i个anchor 预测为目标的可能性，<span><span class="MathJax_Preview">p_i^{*}</span><script type="math/tex">p_i^{*}</script></span>为ground-truth标签。如果这个anchor是positive的，则ground-truth标签为1，否则为0。（即当第i个anchor与GT间IoU&gt;0.7，认为是该anchor是positive，标签为1；反之IoU&lt;0.3时，认为是该anchor是negative，标签为0）</p>
</li>
<li>
<p><span><span class="MathJax_Preview">t_i</span><script type="math/tex">t_i</script></span>表示表示正样本anchor到预测区域bounding box的4个参数化预测结果,<span><span class="MathJax_Preview">t_i^{*}</span><script type="math/tex">t_i^{*}</script></span>是这个positive anchor对应的ground-truth box的偏移，如下所示：</p>
</li>
</ul>
<p>预测值：</p>
<p><img alt="image-20200915101257709" src="../assets/image-20200915101257709.png" /></p>
<p>真实值：</p>
<p><img alt="image-20200915101314285" src="../assets/image-20200915101314285.png" /></p>
<p>其中，x，y，w，h表示窗口中心坐标和窗口的宽度和高度，变量x， <span><span class="MathJax_Preview">x_a 和x^{*}</span><script type="math/tex">x_a 和x^{*}</script></span> 分别表示预测窗口、anchor窗口和Ground Truth的坐标（y，w，h同理）</p>
<p>整个Loss分为两部分：分类和回归的损失</p>
<ul>
<li><span><span class="MathJax_Preview">L_{cls}</span><script type="math/tex">L_{cls}</script></span>分类的损失（classification loss），是一个二分类器的softmax loss。</li>
</ul>
<p><img alt="image-20200915100858122" src="../assets/image-20200915100858122.png" /></p>
<ul>
<li><span><span class="MathJax_Preview">L_{reg}</span><script type="math/tex">L_{reg}</script></span>是回归损失，为<span><span class="MathJax_Preview">smooth(x)</span><script type="math/tex">smooth(x)</script></span>损失,并且只有正样本才参与回归损失计算</li>
</ul>
<p><img alt="image-20200915100839788" src="../assets/image-20200915100839788.png" /></p>
<ul>
<li><span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>和<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span>分别用来标准化分类损失项<span><span class="MathJax_Preview">L_{cls}</span><script type="math/tex">L_{cls}</script></span>和回归损失项<span><span class="MathJax_Preview">L_{reg}</span><script type="math/tex">L_{reg}</script></span>，默认用batch size设置<span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>，用anchor位置数目~2000初始化<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span></li>
<li><span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>和<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span>相差过大，用参数λ来平衡两者，一般取值为<span><span class="MathJax_Preview">N_{reg}</span><script type="math/tex">N_{reg}</script></span>和<span><span class="MathJax_Preview">N_{cls}</span><script type="math/tex">N_{cls}</script></span>的比值10即可。</li>
</ul>
<p>分类损失实现：fasterRCNN/detection/core/loss/losses.py</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">rpn_class_loss</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="n">rpn_class_logits</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;RPN分类损失</span>
<span class="sd">    参数：</span>
<span class="sd">        target_matchs: [batch_size, num_anchors]. anchor的标记信息. 1=positive,</span>
<span class="sd">            -1=negative, 0=neutral anchor.</span>
<span class="sd">        rpn_class_logits: [batch_size, num_anchors, 2]. RPN的分类结果 FG/BG.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1"># 获取anchor的分类标记信息. 将 -1/+1 转换为 0/1 值</span>
    <span class="n">anchor_class</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="c1"># 正负样本对损失都有贡献，获取正负样本的索引</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="c1"># 获取正负样本对应的预测值</span>
    <span class="n">rpn_class_logits</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">rpn_class_logits</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="c1"># 获取正负样本对应的真实累呗</span>
    <span class="n">anchor_class</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">anchor_class</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="c1"># 获取类别个数</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="n">rpn_class_logits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># 计算交叉熵损失结果</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">categorical_crossentropy</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">anchor_class</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">num_classes</span><span class="p">),</span>
                                                 <span class="n">rpn_class_logits</span><span class="p">,</span> <span class="n">from_logits</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># 求平均</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># 返回loss值</span>
    <span class="k">return</span> <span class="n">loss</span>
</code></pre></div>

<p>回归损失：</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">rpn_bbox_loss</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">,</span> <span class="n">target_matchs</span><span class="p">,</span> <span class="n">rpn_deltas</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    rpn损失的回归结果</span>
<span class="sd">    参数：</span>
<span class="sd">        target_deltas: [batch, num_rpn_deltas, (dy, dx, log(dh), log(dw))].</span>
<span class="sd">        target_matchs: [batch, anchors]. Anchor match type. 1=positive,</span>
<span class="sd">            -1=negative, 0=neutral anchor.</span>
<span class="sd">        rpn_deltas: [batch, anchors, (dy, dx, log(dh), log(dw))]</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">batch_pack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">):</span>
        <span class="c1"># 获取指定的位置的值</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_rows</span><span class="p">):</span>
            <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="n">counts</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># 只有正样本计算损失，获取正样本的索引</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="c1"># 获取正样本对应的预测值</span>
    <span class="n">rpn_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">rpn_deltas</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="c1"># 获取正样本的个数</span>
    <span class="n">batch_counts</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_sum</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># 获取正样本对应的目标值</span>
    <span class="n">target_deltas</span> <span class="o">=</span> <span class="n">batch_pack</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">,</span> <span class="n">batch_counts</span><span class="p">,</span>
                              <span class="n">target_deltas</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">as_list</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="c1"># 计算smoothL1损失</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">smooth_l1_loss</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">,</span> <span class="n">rpn_deltas</span><span class="p">)</span>
    <span class="c1"># 计算均值</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="c1"># 返回损失</span>
    <span class="k">return</span> <span class="n">loss</span>
</code></pre></div>

<h5 id="3">3、训练过程<a class="headerlink" href="#3" title="Permanent link">&para;</a></h5>
<p>在训练时每次迭代的正负样本是由一幅图像的正负样本组成的：</p>
<ul>
<li>随机采样256个anchor，计算损失函数，其中采样的正负anchor的比例是1:1。</li>
<li>通过从零均值标准差为0.01的高斯分布中获取的权重来随机初始化所有新层（最后一个卷积层其后的层），所有其他层（即共享的卷积层）是通过对ImageNet分类预训练的模型来初始化的</li>
<li>采用带动量的随机梯度下降算法对网络进行训练</li>
</ul>
<h4 id="452-fastrcnn">4.5.2 FastRCNN网络的训练<a class="headerlink" href="#452-fastrcnn" title="Permanent link">&para;</a></h4>
<p>使用RPN网络收集到的候选区域和imageNet预训练的卷积网络提取的特征对检测的FastRCNN网络进行训练。</p>
<h5 id="1_2">1.正负样本标记<a class="headerlink" href="#1_2" title="Permanent link">&para;</a></h5>
<p>在FastRCNN网络训练时：</p>
<ul>
<li>首先将与真实框ground truth（GT）交并比IOU大于0.5的候选区域设为正样本</li>
<li>将与真实框ground truth（GT）交并比IOU小于0.5的候选区域设为负样本</li>
</ul>
<p>正负样本的分配如下所示：fasterRCNN/detection/core/bbox/bbox_target.py</p>
<div class="highlight"><pre><span></span><code>    <span class="k">def</span> <span class="nf">_build_single_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proposals</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">gt_class_ids</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        生成一幅图像中的正负样本</span>
<span class="sd">        参数：</span>
<span class="sd">            proposals: [num_proposals, (y1, x1, y2, x2)] rpn网络生成的候选区域：归一化坐标</span>
<span class="sd">            gt_boxes: [num_gt_boxes, (y1, x1, y2, x2)] 图像中真实值，bbox的坐标值，图像坐标</span>
<span class="sd">            gt_class_ids: [num_gt_boxes] 图像中的gt对应的类别</span>
<span class="sd">            img_shape: np.ndarray. [2]. (img_height, img_width) 图像的大小</span>

<span class="sd">        返回：</span>
<span class="sd">            rois: [num_rois, (y1, x1, y2, x2)] 候选区域的归一化坐标</span>
<span class="sd">            target_matchs: [num_positive_rois] 采样后候选区域的类别</span>
<span class="sd">            target_deltas: [num_positive_rois, (dy, dx, log(dh), log(dw))] 采样后候选区域的目标值</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># 图像的大小</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">img_shape</span> <span class="c1"># 1216, 1216</span>
        <span class="c1"># 移除0值 [7, 4]</span>
        <span class="n">gt_boxes</span><span class="p">,</span> <span class="n">non_zeros</span> <span class="o">=</span> <span class="n">trim_zeros</span><span class="p">(</span><span class="n">gt_boxes</span><span class="p">)</span> 
        <span class="c1"># 获取GT对应的类别</span>
        <span class="n">gt_class_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">boolean_mask</span><span class="p">(</span><span class="n">gt_class_ids</span><span class="p">,</span> <span class="n">non_zeros</span><span class="p">)</span> <span class="c1"># [7]</span>
        <span class="c1"># 归一化 (y1, x1, y2, x2) =&gt; 0~1</span>
        <span class="n">gt_boxes</span> <span class="o">=</span> <span class="n">gt_boxes</span> <span class="o">/</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([</span><span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="c1"># 计算候选区域和真实框之间的交并比：[2k, 4] with [7, 4] =&gt; [2k, 7]</span>
        <span class="n">overlaps</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">compute_overlaps</span><span class="p">(</span><span class="n">proposals</span><span class="p">,</span> <span class="n">gt_boxes</span><span class="p">)</span>
        <span class="c1"># 获取每一个候选区域最相似的gtbox的索引[2000]</span>
        <span class="n">anchor_iou_argmax</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">overlaps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 获取每一个候选区域与最相似的gtbox的交并比[2000]</span>
        <span class="n">roi_iou_max</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_max</span><span class="p">(</span><span class="n">overlaps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># 获取正样本的索引[2000]=&gt;[48, 1] =&gt;[48]</span>
        <span class="n">positive_roi_bool</span> <span class="o">=</span> <span class="p">(</span><span class="n">roi_iou_max</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_iou_thr</span><span class="p">)</span> 
        <span class="n">positive_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">positive_roi_bool</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span> 
        <span class="c1"># 获取负样本的索引</span>
        <span class="n">negative_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">roi_iou_max</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">neg_iou_thr</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># 对获取的ROI区域进行下采样</span>
        <span class="c1"># 需要的正样本个数，通过比例计算</span>
        <span class="n">positive_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rcnn_deltas</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_fraction</span><span class="p">)</span> 
        <span class="c1"># 将正样本打乱，进行截取</span>
        <span class="n">positive_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">positive_indices</span><span class="p">)[:</span><span class="n">positive_count</span><span class="p">]</span> 
        <span class="c1"># 正样本的个数</span>
        <span class="n">positive_count</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">positive_indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> 

        <span class="c1"># 负样本，保证正样本的比例</span>
        <span class="n">r</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">positive_fraction</span>
        <span class="c1"># 计算样本总数并减去正样本个数，即为负样本个数</span>
        <span class="n">negative_count</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">r</span> <span class="o">*</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">positive_count</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span> <span class="o">-</span> <span class="n">positive_count</span>
        <span class="c1"># 获取负样本</span>
        <span class="n">negative_indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">negative_indices</span><span class="p">)[:</span><span class="n">negative_count</span><span class="p">]</span>

        <span class="c1"># 选取正负样本的候选区域</span>
        <span class="n">positive_rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">proposals</span><span class="p">,</span> <span class="n">positive_indices</span><span class="p">)</span>
        <span class="n">negative_rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">proposals</span><span class="p">,</span> <span class="n">negative_indices</span><span class="p">)</span>

        <span class="c1"># 为选取的候选区域分配目标值，获取正样本与GT的交并比</span>
        <span class="n">positive_overlaps</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">overlaps</span><span class="p">,</span> <span class="n">positive_indices</span><span class="p">)</span>
        <span class="c1"># 获取与每一个候选区域最相似的GT</span>
        <span class="n">roi_gt_box_assignment</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">positive_overlaps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> 
        <span class="c1"># 将GT的坐标和类别分配给对应的候选区域</span>
        <span class="n">roi_gt_boxes</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">gt_boxes</span><span class="p">,</span> <span class="n">roi_gt_box_assignment</span><span class="p">)</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">gt_class_ids</span><span class="p">,</span> <span class="n">roi_gt_box_assignment</span><span class="p">)</span> 
        <span class="c1"># 将坐标转换为修正值</span>
        <span class="n">target_deltas</span> <span class="o">=</span> <span class="n">transforms</span><span class="o">.</span><span class="n">bbox2delta</span><span class="p">(</span><span class="n">positive_rois</span><span class="p">,</span> <span class="n">roi_gt_boxes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_means</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_stds</span><span class="p">)</span>
        <span class="c1"># 将正负样本拼接在一起</span>
        <span class="n">rois</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">positive_rois</span><span class="p">,</span> <span class="n">negative_rois</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># 获取负样本的数量</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">negative_rois</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># 将负样本类别设为0</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">)])</span>
        <span class="c1"># 停止梯度更新</span>
        <span class="n">target_matchs</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="n">target_matchs</span><span class="p">)</span>
        <span class="n">target_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stop_gradient</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">)</span> 
        <span class="c1"># 返回结果</span>
        <span class="k">return</span> <span class="n">rois</span><span class="p">,</span> <span class="n">target_matchs</span><span class="p">,</span> <span class="n">target_deltas</span>
</code></pre></div>

<h5 id="2fastrcnn">2.FastRCNN的损失函数<a class="headerlink" href="#2fastrcnn" title="Permanent link">&para;</a></h5>
<p>FastRCNN的输出由两部分组成：一部分是softmax层进行分类，输出类别有K个类别加上”背景”类，另一部分是回归bounding box regressor。也就是：</p>
<ul>
<li>一部分输出在K+1个类别上的离散概率分布（每个候选区域），<span><span class="MathJax_Preview">p=(p0,p1,...,pk)</span><script type="math/tex">p=(p0,p1,...,pk)</script></span>。通常，通过全连接层的K+1个输出上的Softmax来计算p。</li>
<li>另一部分输出对于由K个类别中的每一个检测框回归偏移，<span><span class="MathJax_Preview">t^{k}=(t_{x}^{k},t_{y}^{k},t_{w}^{k},t_{h}^{k})​</span><script type="math/tex">t^{k}=(t_{x}^{k},t_{y}^{k},t_{w}^{k},t_{h}^{k})​</script></span>。其中<span><span class="MathJax_Preview">t_k​</span><script type="math/tex">t_k​</script></span>指定相对于候选框的尺度不变转换和对数空间高度/宽度移位，与在RPN网络中是一样的。</li>
</ul>
<p>每个训练的候选区域用 <strong>分类目标值u和检测框回归目标值v标记</strong> 。背景样本用u=0来表示，对每个标记的候选区域使用多任务损失L以联合训练分类和检测框回归：</p>
<p><img alt="image-20200915111032596" src="../assets/image-20200915111032596.png" /></p>
<p>其中<span><span class="MathJax_Preview">L_{cls}(p, u) = -\log p_u</span><script type="math/tex">L_{cls}(p, u) = -\log p_u</script></span>，表示交叉熵损失，第二个损失<span><span class="MathJax_Preview">L_{loc}</span><script type="math/tex">L_{loc}</script></span>，是定义目标值和预测检测框的四元组之间的损失使用smoothL1损失计算，同样是只有正样本（非背景）的候选区域才计算回归损失，参数λ设为1。</p>
<p>损失函数的源码如下所示：fasterRCNN/detection/core/loss/losses.py</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">rcnn_class_loss</span><span class="p">(</span><span class="n">target_matchs_list</span><span class="p">,</span> <span class="n">rcnn_class_logits_list</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;FastRCNN的分类损失</span>

<span class="sd">    参数：</span>
<span class="sd">        target_matchs_list:  [num_rois]. 正样本的候选区域</span>
<span class="sd">        rcnn_class_logits_list: list of [num_rois, num_classes] 分类结果</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># 增加背景类的类别</span>
    <span class="n">class_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">target_matchs_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># 背景类的分数</span>
    <span class="n">class_logits</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rcnn_class_logits_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># 类型转换</span>
    <span class="n">class_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">class_ids</span><span class="p">,</span> <span class="s1">&#39;int64&#39;</span><span class="p">)</span>

    <span class="c1"># 获取类别总数</span>
    <span class="n">num_classes</span> <span class="o">=</span> <span class="n">class_logits</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># 计算交叉熵损失函数</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">losses</span><span class="o">.</span><span class="n">categorical_crossentropy</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">one_hot</span><span class="p">(</span><span class="n">class_ids</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">num_classes</span><span class="p">),</span>
                                                 <span class="n">class_logits</span><span class="p">,</span> <span class="n">from_logits</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="c1"># 求平均：大于0返回结果，其他返回0</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">loss</span>


<span class="k">def</span> <span class="nf">rcnn_bbox_loss</span><span class="p">(</span><span class="n">target_deltas_list</span><span class="p">,</span> <span class="n">target_matchs_list</span><span class="p">,</span> <span class="n">rcnn_deltas_list</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;FastRCNN的回归损失</span>

<span class="sd">    参数：</span>
<span class="sd">        target_deltas_list: [num_positive_rois, (dy, dx, log(dh), log(dw))] 正样本对应的真实值</span>
<span class="sd">        target_matchs_list: list of [num_rois]. 正样本对应的类别</span>
<span class="sd">        rcnn_deltas_list: list of [num_rois, num_classes, (dy, dx, log(dh), log(dw))] 网络返回的结果</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># 其他结果为0</span>
    <span class="n">target_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">target_deltas_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">target_class_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">target_matchs_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rcnn_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">rcnn_deltas_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># 只有正样本参与损失计算，并且只有类别预测正确才获取其索引</span>
    <span class="c1"># 获取非背景类的结果</span>
    <span class="n">positive_roi_ix</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">target_class_ids</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="c1"># 将类别和回归结果合并在一起</span>
    <span class="n">positive_roi_class_ids</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span>
        <span class="n">tf</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">target_class_ids</span><span class="p">,</span> <span class="n">positive_roi_ix</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="c1"># 获取索引</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">positive_roi_ix</span><span class="p">,</span> <span class="n">positive_roi_class_ids</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># 获取正样本预测结果</span>
    <span class="n">rcnn_deltas</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">gather_nd</span><span class="p">(</span><span class="n">rcnn_deltas</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>

    <span class="c1"># 计算Smooth-L1损失</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">smooth_l1_loss</span><span class="p">(</span><span class="n">target_deltas</span><span class="p">,</span> <span class="n">rcnn_deltas</span><span class="p">)</span>
    <span class="c1"># 平均：size&gt;0返回结果，否则返回0</span>
    <span class="n">loss</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">reduce_mean</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="k">if</span> <span class="n">tf</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">loss</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loss</span>
</code></pre></div>

<h5 id="3_1">3.训练过程<a class="headerlink" href="#3_1" title="Permanent link">&para;</a></h5>
<p>FastRCNN的训练采用多张图片进行训练，获取每张图片中的正负样本：</p>
<ul>
<li>对所有正样本根据IOU值进行排序，每张图片取前64个区域，将这些区域的坐标保存下来，作为该图片的训练样本</li>
<li>用于Softmax分类和检测框回归的全连接层的权重分别使用具有方差0.01和0.001的零均值高斯分布初始化，偏置初始化为0，特征提取网络使用ImageNet的预训练网络</li>
<li>使用梯度下降算法进行优化</li>
</ul>
<h4 id="453">4.5.3 共享卷积训练<a class="headerlink" href="#453" title="Permanent link">&para;</a></h4>
<p>用fastRCNN检测网络初始化RPN训练，但是固定共享的卷积层，并且只微调RPN独有的层，现在两个网络共享卷积层了，接下来保持共享的卷积层固定，微调Fast R-CNN的fc层。这样，RPN网络和Fast R-CNN网络共享相同的卷积层，构成一个统一的网络。</p>
<p>Faster R-CNN还有一种end-to-end的训练方式，可以一次完成完成，将RPN loss与Fast RCNN loss相加，然后进行梯度下降优化，更新参数。</p>
<hr />
<p><strong>总结</strong></p>
<ul>
<li>了解Overfeat模型的移动窗口方法</li>
</ul>
<p>滑动窗口使用固定宽度和高度的矩形区域，可以在图像上“滑动”，并将扫描送入到神经网络中进行分类和回归。</p>
<ul>
<li>了解RCNN目标检测的思想</li>
</ul>
<p>R-CNN网络使用候选区域方法（region proposal method），利用CNN网络提取特征，SVM完成分类，线性回归进行bbox的修正</p>
<ul>
<li>了解fastRCNN目标检测的思想</li>
</ul>
<p>利用CNN网络进行特征提取，利用SS生成候选区域，进行映射，并使用ROIpooling进行维度调整，最后进行分类和回归</p>
<ul>
<li>熟悉FasterRCNN目标检测的思想</li>
</ul>
<p>利用CNN网络进行特征提取，利用RPN生成候选区域，最后进行分类和回归</p>
<ul>
<li>知道anchor的思想</li>
</ul>
<p>anchor技术将检测问题转换为**"这个固定参考框中有没有目标，目标框偏离参考框多远"**，不再需要多尺度遍历滑窗</p>
<ul>
<li>掌握RPN网络是如何进行候选区域的生成的</li>
</ul>
<p>通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals</p>
<ul>
<li>掌握ROIPooling的使用方法</li>
</ul>
<p>RoIpooling使用最大池化将任何有效的RoI区域内的特征转换成具有H×W的固定空间范围的小feature map</p>
<ul>
<li>知道fasterRCNN的训练方法</li>
</ul>
<p>分步训练：RPN网络，fastrcnn训练，共享网络训练</p>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../01.overview/" title="目标检测概述" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                目标检测概述
              </div>
            </div>
          </a>
        
        
          <a href="../03.RCNN-demo/" title="Faster RCNN案例" class="md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Faster RCNN案例
              </div>
            </div>
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.d710d30a.min.js"></script>
      <script src="../../assets/javascripts/bundle.a45f732b.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.c03f0417.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script>
      
    
  </body>
</html>